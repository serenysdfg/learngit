[TOC]

# 重新刷计划

### 刷题+看题

简单+剑指+经常问道排序等

0319 https://blog.csdn.net/weixin_38118016/article/details/90761111 

 

# Python语法技巧

## 1209刷题笔记

#### 重要： https://blog.csdn.net/serenysdfg/article/details/104584338 

一步步来，一点点解决抓紧 

### 改进

 

```python
if candies<num+1: #写法啰嗦，直接用min来表示那个更小用哪个
    res[i]+=candies
else:
    res[i]= res[i]+num+1
  #改成  
 res[i] += min(num+ 1, candies)
```





### 杂

ranking = collections.defaultdict(lambda: [0] * n)   # 初始化哈希映射

#### 3字符变字典-常用

line.issubset(set(keys)) #查看字符串字母在不在另一个subset   要比查找的集合 

#### 1回文

    def isPalindrome(self, s):#双层递归
        if len(s) <= 1:
            return True
        return s[0] == s[-1] and self.isPalindrome(s[1:-1])
反过来相同



#### 5字符串分割

```python
# 2字符串分割去掉b标点
#2.1
    paragraph = paragraph.replace("!"," ").replace("?"," ").replace(","," ").replace(";"," ").replace(".",' '
            ).replace("'"," ")
   #2.2只要字符
        res=''
        words=[]
        #提取字符
        for i in para:
            if i.isalpha():
                res+=i
            else:
                if len(res)!=0:
                    words.append(res)
                    res='
#2.3

    bool judge(char st)
    {
        if((st>='a' && st<='z')||(st>='A' && st<='Z'))
        {
            return true;
        }
        return false;
```

#### 用到key

```python
# nums=[5, 4, 3, 2, 1]
A = []
for i in range(len(nums)): #变成位置+数字
    A.append([i, nums[i]])
print(A)
A.sort(key = lambda x: x[1], reverse = True)#按值从大到小排序
print(A)
'''[[0, 3], [1, 4], [2, 5], [3, 2], [4, 1]]
[[2, 5], [1, 4], [0, 3], [3, 2], [4, 1]]'''

nums[nums.index(num[0])] = "Gold Medal"  #num[0]最大的值  nums.index(5)5的位置  nums[2]="Gold Medal"

```

***\*对每个数计数-数组\****

```python
c = collections.Counter(nums) #数组计数
​      for item in c.keys(): # c.key  c[item]
​        if c[item] > 1: #大于两个数
​    a, b = map(collections.Counter, (nums1, nums2))#对每个数计数
​    return list((a & b).elements())
```


​        

**if** __name__ == '__main__':

Solution.twoCitySchedCost([[10,20],[30,200],[400,50],[30,20]])

 





### 字典

#### 好451. 根据字符出现频率排序

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        #0221  16：31
        #字典  堆
        str_map={}
        for c in s:
            str_map[c]=str_map.get(c,0)+1
        tmp = sorted(str_map.items(), key=lambda d:d[1], reverse=True)#根据数字排序从大到小
        return ''.join([key*val for key, val in tmp])
#要根据value排序，翻转倒序，并且输出值
```



#### 可高效构建字典：



```python
dec2hex = {**{i: str(i) for i in range(0, 10)}, **{i: chr(87 + i) for i in range(10, 16)}} 
```

次数用字典

#### 1根据值查key



```python
dic = dict(zip(A, B)) #构建字符串映射：
set(zip(s, t))  {('a', 'a'), ('a', 'b')}
```

#### 字典迭代



```python
#t每个元素 t[1]元素的值
for symbol, val in sorted(lookup.items(), key = lambda t: t[1], reverse = True):
```

#### 构建字典

​     if i in maps:

​        maps[i] += 1

 morse_dict = {'a': '.-',  'b':'___'}

#### 字典排序

```python
    maxnum = sorted(dict_tree.values())[-1]#字典排序,最大的
    max(count.values())  # 求元素最大出现次数
​    return [i for i in dict_tree if dict_tree[i] == maxnum] #i是key
#2 两个标准
 sorted(A, key=lambda a: [bin(a).count('1'), a])
```



```python
for i,j in dic.items(): #获取最大的，并记录，更改
    if i not in banned:
        if j>times:
            times=j
            flag=i
return flag
```
————————————————

#### defaultdict

https://www.jianshu.com/p/bbd258f99fd3

用法一般是dict={},添加元素的只需要dict[element] =value即，调用的时候也是如此，dict[element] = xxx,但前提是element字典里，如果不在字典里就会报错

defaultdict的作用是在于，当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值

默认类型：int：1，set：set(), str:空  list：[]

b=collections.defaultdict(int) #a[7]=0

b=collections.defaultdict(list) #a[7]=[]

​    graph = [[] for _ in range(numCourses)]

b=collections.defaultdict(set) #a[7]=set()

### Python的数组

#### 数组变字符串：***\*return\**** ***\*""\*******\*.join(res)\****

直接+就可以 ：digits[:-1] + [0]

digits.insert(0,1)

Append

#### 数组反转

 vals[::-1]

#### ***\*extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）\****

#### 数组互换

a,b = b,a

字符串不行



#### 时间

```python
>>> from timeit import timeit
>>> timeit('x.append(1)', 'x = []', number=10000000)
1.9880003412529277
>>> timeit('x += 1,',     'x = []', number=10000000)
1.2676891852971721
>>> timeit('x += [1]',    'x = []', number=10000000)
3.361207239950204
```

1、mm.append([logs[i][index:],logs[i][0:index]])#偶尔，添加0.1用于后面顺序改变

2、用lst.sort() 而不是nlst = sorted(lst)#成本

3、str[::-1] 代替reverse

4、三目运算符x if y else z

5list填充0

```python
lst = [0 for i in range(3)] # lst = [0,0,0] #ist 填 0
lst  = [[0 for i in range(3)] for j in range(2)]  # lst =  [[0, 0, 0], [0, 0, 0]]
#不好
lst2  =[ 0, 0, 0 ] * 2  # lst2 = [ [0,0,0] , [0,0,0] ] #因为lst1是object，这样写会踩坑
lst2\[0]\[0]  = 1  # lst2 = [ [1,0,0], [1,0,0]]
```

6、

还在用list来做queue么？ deque，当求快queue的时候，你值得拥有
用yield不用return （ 我也还在学习阶段

 bisect.bisect_left #左边排在第几个，或者比第几个大



## 想法

思考。类似处理用递归

统计数量用集合 len(set([morse_rep(word) for word in words])) 看字符里有几个重复的

### 闰年

能被4的倍数但不是100的倍数，或者能被400整除



### 2迭代

二叉树迭代 https://mp.weixin.qq.com/s/FYhn-vuTEU5ZfLdWVqWpsg 

# 输入输出

 https://www.cnblogs.com/HardBass/p/11702919.html 

```python
https://www.cnblogs.com/fat39/p/7159881.html
x=3.56546746
y=4.657567
print ('%.3f'%3.13435)
print('{:.3f} {:.3f}'.format(x,y))  #
print('{0} {1}'.format(x,y))  #x='hello'  y='world'
#不断输入
while True:
    try:
        print(sum(map(int,input().split())))
    except:
        break
```

2

```python
#strip看情况加

#1输入单个输出
n = int(input().strip())
a,b,c=[int(i) for i in input().split()] #也可以用列表获取
用exit()退出

#2获取多行 matrix ，map和for返回的是多个数字，list是一个列表
for _ in range(n): #list(map(int,输入))
    a.append(list(map(int, input().split()))) #append(list(map(int ,输入空格区别)))
    #h或者
for _ in range(n):  #[int(i) for i in 输入]
    list.append([int(i) for i in input().split()])
    
for _ in range(n):  #sys
    List =list( map(int, sys.stdin.readline().split())) #然后每行处理
 
 
#用sys.stdin读取行  sys.stdin.readline().

n, m = map(int, sys.stdin.readline().split()) #单行输入
n = int(sys.stdin.readline().strip())
 
 
import sys 
if __name__ == "__main__":
for line in sys.stdin:
    a = line.split()
    print(int(a[0]) + int(a[1])) #每一行相加输出
 
#输出
a= [‘1’,‘2’,‘3’,‘4’]
print(’ ‘.join(a)）
 
print(result(state)[:-1])
 
 
 
import sys
if __name__ == "__main__":
    ys.stdin = open("input.txt", "r")
```



# 常用

写代码检查拼写，细心快速

标志很重要，状态，逻辑

利用字典：链表，指针，dp

​    s = S.replace("-","") #方便没想到 有用常常忘记

```python
#数字
while n!=0:
    b.append(n%10)#每一位数字
    n//=10#移除个位
```



### 记住

 [−2^31, 2^31 − 1] 

[-2147483648，2147483647 ]

um>2147483647 or sum<-2147483648:return 0 [−2^31, 2^31 − 1]

### 7数学

### 204计数质数

### 质 数筛法，

减少了逐一检查每个数的的步骤，可以比较简单的从一大堆数字之中，筛选出质数来，这方法被称作厄拉多塞筛法 

具体操作：先将 2~n 的各个数放入表中，然后在2的上面画一个圆圈，然后划去2的其他倍数；第一个既未画圈又没有被划去的数是3，将它画圈，再划去3的其他倍数；现在既未画圈又没有被划去的第一个数是5，将它画圈，并划去5的其他倍数……依次类推，一直到所有小于或等于n的各数都画了圈或划去为止。这时，表中画了圈的以及未划去的那些数正好就是小于 n 的素数

```python
if n <= 2:
    return 0
li = [0 for i in range(0,n)] #0是质数
li[0] = 1
li[1] = 1
cont = 0
for i in range(2,n):
    if li[i] == 0:
        # print(i)
        cont += 1
        for j in range(i+i,n,i):#4+2+2  3+3+3
            li[j] = 1
return cont
```




#####  如果一个数 i 和 i - 1 做与运算，那么 i 的二进制表示形式中的最右边一个 1 会变成0 :计数1个数

```python
    def getOne(self, n):
        cnt = 0
        while(n):
            cnt += 1
            n = n & (n - 1)
        return cnt
```

##### 将一个整数拆分，往往这个拆分后的数中包含整数的话，那么这些数的乘积最大



### 6deque

 Python的collections中有一个deque,这个对象类似于list列表，不过你可以操作它的“两端”。比如下面的例子： 

 https://blog.csdn.net/liangguohuan/article/details/7088265 

### 5数字-计算器

stack

优先级高的，stack出来计算

空格+1

字符。数字，空格分开

```python
while i < len(s) and s[i].isdigit():#连续数字，可能二位或者三位
    tmp = tmp * 10 + int(s[i])
    i += 1
```

### 3分组

```python
            x = ''.join(sorted(list(i)))#转换相同的
            if x in mapx:
                mapx[x].append(i)
            else:
                mapx[x] = [i]
```



### 2常用结构-回溯，递归

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        #copy如果左括号已经用完了，则不能再加左括号了。
        # 如果已经出现的右括号和左括号一样多，则不能再加右括号了。因为那样的话新加入的右括号一定无法匹配。
        self.res = []
        self.singleStr('', 0, 0, n)
        return self.res
        
    def singleStr(self, s, left, right, n):
        if left == n and right == n: #一种结果
            self.res.append(s)
        if left < n:
            self.singleStr(s + '(',left + 1, right,n)#递归后面情况
        if right < left:
            self.singleStr(s + ')',left, right + 1, n) #也递归
```

### 1大数计算

415，43

```python
carry += ord(num1[i]) - ord('0')#变成ascii
chr函数
num1, num2 = num1[::-1], num2[::-1]python
```



# 题目类型归纳(按照题目很像的)

## 滑动窗口

https://mp.weixin.qq.com/s/bgB30IK2SoBcg1YOEmVhCg

 主要用来处理连续问题。比如题目求解“连续子串 xxxx”，“连续子数组 xxxx”，就应该可以想到滑动窗口。 

固定窗口：

初始化l，r：l==0,使得 r - l + 1 等于窗口大小 , 同时移动 l 和 r 

可变窗口： l 和 r 都初始化为 0 ：  指针不停向右移动，l 指针仅仅在窗口满足条件之后才会移动，起到窗口收缩的效果 

## 最长问题0223-dp

### 最长公共子串-剑指

```python
#给出两个字符串，找到最长公共子串，并返回其长度。
class Solution:
    # 动态规划解决最长公共子串问题
    # 时间复杂度O(m*n), 空间复杂度O(m*n)
    def longestCommonSubstring(self, A, B):
        lenA, lenB = len(A), len(B)
        if A == None or B == None or len(A) + len(B) == 0:
            return 0
        #DP[I][J]:前i个和前j个最长公共长度A[i-1]=B[i-1]那就i个j个相等
        C = [[0] * (lenB+1) for i in range(lenA + 1)]
        maxLen, maxIndex = 0, 0
        for i in range(1, lenA + 1):
            for j in range(1, lenB + 1):
                if A[i-1] == B[j-1]:
                    C[i][j] = C[i-1][j-1] + 1
                    if C[i][j] > maxLen:
                        maxLen = C[i][j]
                        maxIndex = i - maxLen
        LCS = A[maxIndex:maxIndex + maxLen]
        return maxLen, LCS
```

### 300最长上升子序列

 定义 dp[i]*d**p*[*i*] 为考虑前 i 个元素，以第 *i* 个数字结尾的最长上升子序，**注意 \textit{nums}[i]\*nums\*[\*i\*] 必须被选取** 

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:      
        dp = []
        for i in range(len(nums)):
            idx=0
            for j in range(len(dp)):
                if nums[i]>dp[j]:
                    idx=j+1
           # idx = bisect_left(dp, nums[i])#插入:二分提高效率
            if idx == len(dp):
                dp.append(nums[i])
            else:
                dp[idx] = nums[i]
        return len(dp)
    
```



## 排序算法

**https://mp.weixin.qq.com/s/KWf_1Ntbo3WM52JWkP70Cg**

空间复杂度：只有堆和基数nlogn

#### 堆排序

```
##2
def QuickSort(myList):
    start,end=0,len(myList)-1
    if start < end: #判断low是否小于high,如果为false,直接返回
        i,j = start,end
        base = myList[i]#设置基准数

        while i < j:
            #如果列表后边的数,比基准数大或相等,则前移一位直到有比基准数小的数出现
            while (i < j) and (myList[j] >= base):
                j = j - 1

            #如找到,则把第j个元素赋值给第个元素i,此时表中i,j个元素相等
            myList[i] = myList[j]

            #同样的方式比较前半区
            while (i < j) and (myList[i] <= base):
                i = i + 1
            myList[j] = myList[i]
        #做完第一轮比较之后,列表被分成了两个半区,并且i=j,需要将这个数设置回base
        myList[i] = base

        #递归前后半区
        QuickSort(myList, start, i - 1)
        QuickSort(myList, j + 1, end)
    return myList
```

 从最后一个非叶子结点开始（第一个非叶子结点 arr.length/2-1），判断其和叶子节点大小，最大的放到根节点，小的放到叶子节点--还要考虑此叶子节点为跟的子树是否仍满足条件）
每次交换都要把改变了的那个节点所在的树重新判定一下

 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 



 https://blog.csdn.net/serenysdfg/article/details/104644815 

直接选择：两轮循环，每轮都要依次比较选择最小的放到前面

插入排序： 无序变成一个有序，每次拿出一个数字插入到新的有序中 ，移动

​	最好：每次比较一次就可以插入O(n) ，最坏O（1）

####  **4冒泡排序** 

n轮每次把最大的移到最后，最好情况：加入标记swaptrue，如果循环没有进行交换，可以理解为数组已经排好序，一轮后就可以退出排序；

#### **5快速排序**-重点（选一个基数从从后往前前往后

 https://blog.csdn.net/nrsc272420199/article/details/82587933 （图解）

 https://blog.csdn.net/A_BlackMoon/article/details/81064712 （复杂度）

```python
def quick_sort(list1):
	if len(list1) < 1:return list1
    
	num = list1[0]
    start = [x for x in list1[1:] if x <= num]
    end = [x for x in list1[1:] if x > num]
    return quick_sort(start) + [num] + quick_sort(end)
#非递归--    模拟栈操作实现非递归的快速排序

```

#### 6归并排序：各自分治拍好后合并两个有序数组

 https://www.cnblogs.com/chengxiao/p/6194356.html 

#### 7插入排序

选前面的插入到已经排好

基数排序-桶pai'xu





### 快速+分治

```python
#快递排序递归部分，只要left<right 则取其某数作为中心点分界，以此类推。
class Solution(object):
    def quicksort(self, arr, left, right):
        if left < right:
            position = self.Partition(arr, left, right)
            self.quicksort(arr, left, position-1)
            self.quicksort(arr, position+1, right)
        return arr
#partion函数部分：

    #一个Point的方法，以left为轴心，以 pivot 为分界线将数组中其他元素分为两部分，使得左边部分的数小于等于枢轴，右边部分的数大于等于枢轴
    def Partition(self, arr, left ,right):
        index = left
        pivot = arr[left]
        for i in range(left+1, right+1):
            if arr[i] < pivot:
                index += 1
                if i != index:
                    arr[i], arr[index] = arr[index], arr[i]
        arr[index], arr[left] = arr[left], arr[index]
        return index

    #两个point的方法
    def Partition(self, arr, left ,right):
        pivot = arr[left]
        while left < right:
            while left < right and arr[right] > pivot:
                right -= 1
            arr[left] = arr[right]
            while left < right and arr[left] <= pivot:
                left += 1
            arr[right] = arr[left]
        arr[left] = pivot
        return left
```







##  大数计算 



## 背包问题

## n数之和--求和类

 https://blog.csdn.net/siyue0211/article/details/80947251 

### 三数之和 le15

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n, res = len(nums), []
        nums.sort()#先排序
        for i in range(n):
            if i > 0 and nums[i] == nums[i-1]:   # 因为i=0这个元素会直接往下执行 ，i从1开始，#重要防止重复  
                continue
            l, r = i+1, n-1
            while l < r:  #指针查找
                tmp = nums[i] + nums[l] + nums[r]
                if tmp == 0:
                    res.append([nums[i], nums[l], nums[r]]) #左边变大右边肯定变小
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l-1]:  #重要防止重复
                        l += 1
                    while l < r and nums[r] == nums[r+1]: #重要防止重复
                        r -= 1
                elif tmp > 0:
                    r -= 1
                else:
                    l += 1
        return res
```

### n数之和 le16

 **找出 nums 中的三个整数，使得它们的和与 target 最接近。**先排序 

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        # 指针，num[i]+begin+end判断距离，更近就加1，更远就-1  15.15-35 ：30min
        if len(nums)<=3:return sum(nums)
        nums.sort() #-3 0 1 2
        
        mind=float('inf')
        for i in range(1,len(nums)-1):
            l,r=0,len(nums)-1 #从头开始
            while i>l and i<r:
                s=nums[i]+nums[l]+nums[r]
                if abs(s-target)<mind: #位置每一个都有可能绝对值更小
                    mind=abs(s-target)
                    res=s
                if s==target:return s
                elif s>target: 
                    r-=1
                else :
                    l+=1

        return res
```



## 买卖股票-重要：

 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/   （股票方法）

```python
dp[i][k][s]第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])#昨天就无或今天卖掉
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) #昨天有，今天买
```

多层累计和问题

### 121 买卖股票的最佳时机：俩个变量，记录一个max

```python
#重要，不熟练，状态方程变得更小，下一轮上涨计算
max_cur = max(0, max_cur+prices[i]-prices[i-1]) #如果今天卖相比于昨天卖能多赚，则今天卖，prices[i]-prices[i-1]累积就是那一天-最小那天，变成负重新算
res = max(res, max_cur)#曾经最大+现在新的大值比较，在正的某一段记录最大
```

### 122.买卖股票的最佳时机 II：也是遍历一遍

```python
def maxProfit(self, prices: List[int]) -> int:
    if not prices:return 0
    low = high = prices[0]
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] >= prices[i - 1]: high = prices[i] #波峰
        else:
            profit += high - low  #获取波峰-波谷
            low = high = prices[i]
    profit += high - low
    return profit
```

### 309最佳买卖股票时机含冷冻期（重要

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #0309
        #dp_i_0=max(dp_i_1，dp_i_0) 前一天就不持有，前一天卖掉
        if not list:return 0
        dp_i_0,dp_pre=0,0
        dp_i_1=float('-inf')
        for i in range(len(prices)):
            temp=dp_i_0 
            dp_i_0=max(dp_i_0,dp_i_1+prices[i])#卖掉
            dp_i_1=max(dp_i_1,dp_pre-prices[i])#本来没有的买入,隔一天买入
            dp_pre=temp #冷冻期，最后一天
        return dp_i_0
```

### 714买卖股票的最佳时机含手续费

​      dp_i_0=max(dp_i_0,dp_i_1+prices[i]-fee) #买入要费用

### 188 买卖股票的最佳时机 IV

你最多可以完成 k 笔交易。

```python

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size < 2:return 0
        dp = [0 for _ in range(5)]
        dp[0] = 0
        dp[1] = -prices[0]
        dp[3] = float('-inf')
        for i in range(1, size):
            dp[0] = 0
            dp[1] = max(dp[1], - prices[i])# j = 1：第 1 次买入一支股票
            dp[2] = max(dp[2], dp[1] + prices[i])  # j = 2：第 1 次卖出一支股票
            dp[3] = max(dp[3], dp[2] - prices[i])  # j = 3：第 2 次买入一支股票
            dp[4] = max(dp[4], dp[3] + prices[i])  # j = 4：第 2 次卖出一支股票
        return max(0, dp[2], dp[4])
```

### 123 买卖股票的最佳时机 III ：困难

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices: return 0
        n = len(prices)
        max_k = 2
        dp = [[[0]*2 for _ in range(max_k+1)] for _ in range(n)]
        for k in range(3):
            dp[0][k][1] = -prices[0] #buy 操作时，dp[0][k][1]=-prices[0]
        # 从 i=1 处开始迭代
        for i in range(1, n):
            for k in range(1, 3):
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i])
        return dp[n-1][2][0]

```



## 日期计算

### str 数组 时间戳

```python
import time
#字符类型的时间
tss1 = '2013-10-10 23:40:00'
#字符转为时间数组
timeArray = time.strptime(tss1, "%Y-%m-%d %H:%M:%S")#时间数组：time.struct_time(tm_year=2013, tm_mon=10, tm_mday=10, tm_hour=23, tm_min=40, tm_sec=0, tm_wday=3, tm_yday=283, tm_isdst=-1)
#timeArray可以调用tm_year等
print timeArray.tm_year   # 2013

#使用 time获取当前时间戳
now = int(time.time())     # 1533952277
# datetime获取当前时间，数组格式
now = datetime.datetime.now() #2018-08-11 09:51:17.362986
otherStyleTime = now.strftime("%Y--%m--%d %H:%M:%S")#2018--08--11 09:51:17

#使用time数组转为时间戳
timeStamp = int(time.mktime(timeArray))# 1381419600
#使用time时间戳转化成数组
timeArray = time.localtime(timeStamp)
# 使用datetime 时间戳转化成数组
timeStamp = 1381419600
dateArray = datetime.datetime.fromtimestamp(timeStamp)
# 使用datetime，指定utc时间，相差8小时
dateArray = datetime.datetime.utcfromtimestamp(timeStamp) # 2013--10--10 15:40:00

# 数组转为其它字符显示格式
otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)# 2013/10/10 23:40:00

```



###  计算两个日期之间隔了多少天 

```python
class Solution(object):
    def daysBetweenDates(self, date1, date2):
        def f(date):
            import time
            timeArray = time.strptime(date, "%Y-%m-%d")
            return int(time.mktime(timeArray))
        return abs((f(date2) - f(date1))//86400)
 #2
import datetime
class Solution(object):
    def daysBetweenDates(self, date1, date2):
        date1=datetime.datetime.strptime(date1,"%Y-%m-%d")
        date2=datetime.datetime.strptime(date2,"%Y-%m-%d")
        num=(date1-date2).days
        return abs(num)
```



## 子字符串

### 最长增长子序列

```
用longest increasing subsequence来求，超时

class Solution(object):
    def increasingTriplet(self, nums):
    	if not nums: return False
        n = len(nums)
        dp = [1 for i in range(n)]
        for i in range(1,n):
        	for j in range(i):
        		if nums[i] > nums[j] :
        			dp[i] = max(dp[i],dp[j] + 1)
        			if dp[i] >= 3:
        				return True

        return False用longest increasing subsequence来求，超时

class Solution(object):
    def increasingTriplet(self, nums):
    	
```



## 丑数（质数

263.313.314

### 263丑数-简单（判断

```python
class Solution:
    def isUgly(self, num: int) -> bool:
        #只能被质数整除。质数不断相加，还有一题难一点的？忘了哪题
        #me
        if num == 0 : return False  #重要，不然超时 0%2始终是0
        while num%2==0:
            num//=2
        while num%3==0: #能被整除
            num//=3
        while num%5==0:
            num//=5
        if num==1:return True
        return False
        #copy
        for p in [2, 3, 5]:
            while num and num%p == 0:
                num //= p
        return num == 1

```



### 313 超级丑数-堆中等  DP下次再看

```python
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        # 3copy
        dp = [1] #dp[0]=1
 
        lenPrimes = len(primes)
        idxPrimes = [0] * lenPrimes
        counter = 1
        while counter < n:
            min = pow(2, 32)
            for i in range(0, lenPrimes):
                temp = dp[idxPrimes[i]] * primes[i] #获取最小值
                if temp < min:
                    min = temp
 
            for i in range(0, lenPrimes):
                if min == dp[idxPrimes[i]] * primes[i]:
                    idxPrimes[i] += 1#找到对应的最小值
            dp.append(min)
            counter += 1
 
        return dp[counter - 1]
```

#### 0128剑指offer丑数

```
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
```

```python
## 更新三个指针指向下一次操作就会变成最大值的位置。就能一直生成下一丑数。
class Solution:
    def GetUglyNumber_Solution(self, index):
        if index < 1:
            return 0
        res = [1]
        t2 = t3 = t5 = 0
        nextNum = 1
        while nextNum < index:
            minNum = min(res[t2] * 2, res[t3] * 3, res[t5] * 5) #2,3,5    2把最小的依次放进去
            res.append(minNum)
            if res[t2] * 2 <= minNum:
                t2 += 1
            if res[t3] * 3 <= minNum:
                t3 += 1
            if res[t5] * 5 <= minNum:
                t5 += 1
            nextNum += 1
        return res[nextNum - 1]

```



## 回文：（11.29未看完

### 214最短回文

```python
方法二：双指针与递归 [通过]
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        n=len(s)
        i=0
        for j in range(n-1,-1,-1):
            if s[i]==s[j]:
                i+=1
        if i==n:return s

        remain_rev=s[i:][::-1]
        return remain_rev+self.shortestPalindrome(s[:i])+s[i:]

```

马拉车（Manacher）算法是在O（n）时间内解决寻找源字符串的最长回文子串S的问题的算法。(很麻烦

**朴素算法**情况下对于每一个S[i]都要左右遍历其最大回文子串，所以时间复杂度是O（n2）

 一般的思路是以当前字符为中心，向其左右两边扩展寻找回文 

 回文区间 `[a, b]`  则[a+1,b-1]递归回文

### 马拉车-文子串

```python
解释:https://www.jianshu.com/p/392172762e55
在每个字符左右两边插入#将字符串变成奇数串arr
2计算p数组
p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。


最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1
最长回文子串的起始索引int index = (i - p[i])/2。
def countSubstrings(self, S):
    def manachers(S):
        A = '@#' + '#'.join(S) + '#$'
        Z = [0] * len(A)
        center = right = 0
        for i in xrange(1, len(A) - 1):
            if i < right:
                Z[i] = min(right - i, Z[2 * center - i])
            while A[i + Z[i] + 1] == A[i - Z[i] - 1]:
                Z[i] += 1
            if i + Z[i] > right:
                center, right = i, i + Z[i]
        return Z

    return sum((v+1)/2 for v in manachers(S))
```





### 回文子串

 从每一个回文串中心开始统计回文串数量 

```python
class Solution(object):
    def countSubstrings(self, S):
        N = len(S)
        ans = 0
        for center in range(2*N - 1):
            left = center // 2
            right = left + center % 2
            while left >= 0 and right < N and S[left] == S[right]:
                ans += 1
                left -= 1
                right += 1
        return ans

```

5.9.125.131.132.214.234.266.267.336.409.479.516.564.647.6880.730.833.906.1147.1177.1216.1246

### 5 最长回文子串-dp--尝试

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。 

优秀解说： https://blog.csdn.net/u013309870/article/details/70742315 

    mem = [[False for _ in range(size)] for _ in range(size)]
    
    for r in range(size):
        for l in range(r + 1):
            if s[l] == s[r] and (r - l <= 2 or mem[l + 1][r - 1]):
                mem[l][r] = True
```python
#最笨的方法，就是依次把每一个字符当做回文字符串的中间的那个字符，向两边扩展
时间复杂度O（n^2）,空间复杂度为O（1）
#2 s和 reverse(s) 共有的最长的 substring 需要检查子串的索引是否与反向子串的原始索引相同，不相同就不是 S=“abacdfgdcaba”, S' =“abacdgfdcaba”：  'caba' 'abac'
#3dp：m[x][y] x到y位置的最长串的长度
class Solution:
    def longestPalindrome(self, s: str) -> str:   
        if not s:return ""
        #dp:f(i,j)=f(i+1,j−1) si=sj,f(i,j)表示区间在[i,j]内的字符串是不是回文串
        s_len = len(s)
        mem = [[0]*s_len for _ in range(s_len)]
        left, right, result_len = 0, 0, 0
        
        for j in range(s_len): #重要
            for i in range(j):
                if s[i] == s[j] and (j-i < 2 or mem[i+1][j-1]):
                    mem[i][j] = 1 #相邻或  或者中间已经回文
                if mem[i][j] and result_len < j-i+1:
                    result_len = j - i + 1
                    left, right = i, j
            mem[j][j] = 1 #自己
        return s[left:right+1]
#4Manacher 间复杂度O（n）,空间复杂度O（n）
中心扩展时用前面遍历的时候产生的回文子串--再看吧
```

### 9回文数-简单

```python
#1左右对比
left,right=0,len(x)-1
#转成字符串
x != int(str(x)[::-1]):
```

### 验证回文字符串 Ⅱ-可以删除字符

```python
    def validPalindrome(self, s: str) -> bool:
        l,r=0,len(s)-1
        flag=0#未删除字符
        while l<r:
            if s[l]!=s[r]:
                flag=1
                break
            l+=1
            r-=1
        if flag==0:return True
        s=s[l:r+1]
        return s[:-1]==s[:-1][::-1] or s[1:]==s[1:][::-1]#去除左边或者右边
```



### 10正则表达式匹配-经典

```python
        '''当模式中的第二个字符不是*时：
1. 如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。
2. 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。

而当模式中的第二个字符是*时：
如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：
1. 模式后移2字符，相当于x*被忽略；
2. 字符串后移1字符，模式后移2字符；

'''
    # -*- coding:utf-8 -*-
class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        # write code here
        if s == pattern:
            return True
        if not pattern:
            return False
        if len(pattern)>1 and pattern[1] == '*': #第二个是*
            if(s and s[0]==pattern[0]) or (s and pattern[0] == '.'):
                return self.match(s,pattern[2:])  or self.match(s[1:],pattern) or self.match(s[1:],pattern[2:])
            else:
                return self.match(s,pattern[2:])
        elif s and (s[0] == pattern[0] or pattern[0]=='.'):#后面一个字符，一个对应一个
                return self.match(s[1:],pattern[1:])
        return False

```

### 131分割回文

```
输入: "aab"
输出:[ ["aa","b"], ["a","a","b"]]
```

```python
    def partition(self, s: str) -> List[List[str]]:
        self.res = []
        self.dfs(s,[])
        return self.res
    def dfs(self, s, stringList):
        if len(s) == 0: self.res.append(stringList)
        for i in range(1,len(s)+1):
            if s[:i]==s[:i][::-1]: #回文，#分割1，2，3判断是不是，是就下一段再继续分割1，2，3递归
                self.dfs(s[i:],stringList + [s[:i]])
```



### 266回文排列

每个数左右+-用字典

## 好的题目

### 1366投票对团队排名（数组）

```python
'''输入：votes = ["ABC","ACB","ABC","ACB","ACB"]
输出："ACB"
解释：A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。
B 队获得两票「排位第二」，三票「排位第三」。
C 队获得三票「排位第二」，两票「排位第三」。
由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。
'''
class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        #0302 copy 好题:计数题目 ，用字典[0,0,0,0,0,0] rank[A]:每位有几票
        n = len(votes[0])  #人数
        ranking = collections.defaultdict(lambda: [0] * n)   # 初始化哈希映射
        # 遍历统计，难点
        for vote in votes:
            for i, vid in enumerate(vote):
                ranking[vid][i] += 1
        
        # 取出所有的键值对
        result = list(ranking.items())
        # 排序
        result.sort(key=lambda x: (x[1], -ord(x[0])), reverse=True) #对键值对排序降序(key排序数组（自动一个个比较），再按照字母排序)
        return "".join([vid for vid, rank in result])


```



### 78子集：Leetcode 78：子集  #递归，

最短路径算法

 Dijkstra算法 、 Floyd 

数组存储最短，矩阵村春

### 743网络延迟时间- Dijkstra算法 

```
class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        #有向图,最短传播路径,找到最短路径,经过某个点到另一个点和从这个点直接出发那个更短,更新
        # arr[K-1]就是K到其他点的距离 ,一道多点到多点的最短路径问题，用floyd算法最合适

        arr=[[float('inf') for _ in range(N)]for _ in range(N)] #二维数组,最长
        for t in times:#N全部变成0-N
            x=t[0]-1 
            y=t[1]-1
            arr[x][y]=t[2]
        for i in range(N):
            arr[i][i]=0 #对角=0
        for k in range(N):#经过1节点,会不会更短,更新
            for i in range(N):
                for j in range(N):
                    if arr[i][j]>arr[i][k]+arr[k][j]:#i到j,变成更小的
                        arr[i][j]=arr[i][k]+arr[k][j]
        if float('inf') in arr[K-1]:#不能没有值
            return -1
        return max(arr[K-1])#返回最久,全部都能到达
```



### DFS:1367

### 数组，位运算

### 3股票买入卖出

121  122  309中等难度

## 2第n个排列：字典序列

#### #字典序算法

比如给定一种排列为 abc，则其基于字典序的下一种排列为 acb。

要求下一种排列既要比原排列大，又不能有第三种排列位于他俩之间。即下一种排列为大于原排列的最小排列。

以输入为 358764 为例，字典序算法的步骤：
1、从原排列中，从右至左，找到第一个左邻小于右邻的字符，记左邻位置为 a。
示例中 a=1，list[a] = 5。
2、重新从右至左，找到第一个比 list[a] 大的字符，记为位置为 b。
示例中 b=4，list[b] = 6。
3、交换 a 和 b 两个位置的值。
示例变为了 368754。
4、将 a 后面的数，由小到大排列。
示例变为了 364578。

算法结束，输出 364578。


**60. 第k个排列** 

## 1括号+计算

利用stack

224 基本计算器-困难 （遇到左括号开始计算，所以先从后往前

20 有效的括号 （判断字符串是否有效

22.括号生成

227.计算器-中等

# 题目类型归纳(按照分类)



## 1.1数组类

 d.pop()  || d.leftpop()

entend() ||  entendleft()

```python

二维数组定义
 dp = [[1 for i in range(m)] for j in range(n)] 
 mem = [[0]*n for _ in range(m)] 
 
return len(nums) != len(set(nums)) #是否重复用setc常用
nums.sort()
 
题目方法：
6连续数组缺失数据--用数学公式，sum
return int(len(nums) * (len(nums) + 1) / 2 - sum(nums)) #等差数列前n项和减去数组之和,一行瞬秒
7将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。、先移除再增加
nums.remove(0)
nums.extend([0]*i)
 
1比较是否相等数据元素在
while val in nums:
    nums.remove(val)
 
2排序
2.2nums1[m+n-1] = nums1[m-1] #最大的放到最后,从后面往前
 
*5数组的交集，可以重复*

```



#### 没看：

697，717

 使用itertools.combinations组合所有的可能情况, 然后依次遍历即可. 

字典就是哈希

### 0309看题总结：dp，指针，字典，查找

 **数组前缀和的理解和**作用 ：重要

**找和**最接近目标三个数：i层，num[i]+两个指针：1排序后2指针不断移动

**找和**四个数：1字典双层循环前两个 2双循环值-后两个 3值在字典中加入集合

对角线有相同元素：**矩阵问题**注意位置，i+1，j+1

要增强：分治53

**和相加：**字典记录下标求另一个是否存在；排序的话可以用指针不断收缩

两数和：

**杨辉三角生产：**规律：上一行之和生成数组循环 2返回第k行：

股票，最大连续：**状态转移问题**

数组：考虑0，**倍数问题**考虑计数

**字符串和数组数字转换**：66加一：carry循环继续

**字典或者计数**：collections.Counter(nums) 

计算利用规律，**排列组合**方法

比较：利用三个变量遍历时更新（414第三大的数

数组移动改变值（453好）

**重复问题利用set**

供暖器问题+俄罗斯套娃（w下降寻找最优的第二个上升）：二分查找找位置， **最长递增子序列**

 ***LIS*算法**（Longest Increasing Subsequence）最长上升（不下降）子序列 

多个计数可以用数组保存（485连续1的个数）

**数组递归**：pre,ppre = pre+ppre,pre ，更新现在值，存以前值（509）



数组拆分：获取元组最小和的最大min(1,2)+min(3,4)：先排序早规律

**滑动窗口**（661图片平滑器）

改变元素非递减（665）：计数可以改变1次

**原地**排序：有规律直接交换，用字典



#### 题目：中等 很多都是矩阵

581最短无序**连续子数组**：找到最短序列排序后整个都有序：1先排序，while左右指针和排序的不一样 3返回right-left+1

334**递增三元子序列**：

```
规律：小于当前的最小值，那么更新当前最小值
小于当前第二小值，更新当前第二小值
如果以上两种都不是，那么是大于当前第二小值和最小值，于是这样就true
```

643子数组最大平均数：找出长度为k的连续子数组：#先记录最大，然后依次加后一个减去第一个，比较是否更大

628最大乘积：找规律，找最大最小值

36数独：dic_row = [{},{},{},{},{},{},{},{},{}] 字典存储9行 dic_row[i] 是字典 dic_row[i] [数字]=1不重复，在字典中就重复  if num == ".": continue

56**区间**合并：重叠更改end的1选择更大值，不重叠加进res

228汇总区间：两个指针左右， 差值等于 1 的就将它们被放在同一段区间内 ，

​						一个指针不断右移动如果+1，如果不移动就是单独数

48**矩阵 旋转**图像 90度：行上下翻转后对角线，直接**互换**

**54矩阵螺旋读取**：4个边界，行列读取后-1 ，满足x1 <= x2 and y1 <= y2: 等条件

59螺旋矩阵2：

73矩阵置零：标记第一行第一列要不要为0

74**矩阵查找**：找到行再找列，二分查找

1366投票对团队排名：ranking = collections.defaultdict(lambda: [0] * n) 每位有机票在排序



#### 相邻问题小偷

605种花问题：边界问题可以两边+[0],连续三个0可以种

#### **数组和索引有关**：

1考虑**字典值为索引** ，

2两个指针，idx索引不断增加（283移动0：和0的直接替换）

3索引和数字一起元组（506名相对名次A.append([i, nums[i]])

4直接利用n.index(i)==0:



### 300.LIS最长上升子序列+俄罗斯套娃-不连续

```python
def lengthOfLIS(self, nums: List[int]) -> int: #容易超时
    #可以不连续：dp 这个数字截止的最长序列
    if not nums: return 0
    dp = [1 for i in range(len(nums))]
    for i in range(1, len(nums)):
        for j in range(i):#两轮循环
            if nums[i] > nums[j]:
                dp[i] = max(dp[j] + 1, dp[i])  #比他大，就再加1
    return max(dp)

#3
        def lis(nums):
            dp = []
            for i in range(len(nums)):
                idx=0
                for j in range(len(dp)):
                    if nums[i]>dp[j]:
                        idx=j+1
                # 上面四句话可以改成：idx = bisect_left(dp, nums[i])#插入位置
                if idx == len(dp):
                    dp.append(nums[i])
                else:
                    dp[idx] = nums[i]
            return len(dp)
```



### 53 最大子序和：最大和连续子数组（分治法递归计算

\#转移方程，每一个位置都有状态。

```python
def maxSubArray(self, nums: List[int]) -> int:
#动态规划,copy 只关注：当然值 和 当前值+过去的状态，是变好还是变坏;到i处的最大值两个可能，一个是加上a[i], 另一个从a[i]起头
    n = len(nums)
    maxSum = [nums[0] for i in range(n)]
    for i in range(1,n):
        maxSum[i] = max(maxSum[i-1] + nums[i], nums[i])#加上前面的更小或者更大
    return max(maxSum)
#2#类似，换个写法
def maxSubArray(self, nums: List[int]) -> int:
    n = len(nums)
    maxSum , maxEnd = nums[0], nums[0]
    for i in range(1,n):
        maxEnd = max(nums[i],maxEnd + nums[i]) 
        maxSum = max(maxEnd,maxSum)#一个个比较max，上面是一次性max
    return maxSum

```



### 常用：前缀和思想（重要、

总和值为零的连续节点:

preSum[i]=1+2=3，而preSum[j]=1+2+3+4=10，那么sum([i+1,j])=preSum[j]-preSum[i]=7。这是一个非常好的性质，我们可以通过一个字典存储每个前缀和对应的节点，如果有两个节点的前缀和相同，那么说明这个区间内的和是0

### 其他

```python
二维数组定义
 dp = [[1 for i in range(m)] for j in range(n)] 
 mem = [[0]*n for _ in range(m)] 

return len(nums) != len(set(nums)) #是否重复用setc常用
nums.sort()

题目方法：
6连续数组缺失数据--用数学公式，sum
return int(len(nums) * (len(nums) + 1) / 2 - sum(nums)) #等差数列前n项和减去数组之和,一行瞬秒
7将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。、先移除再增加
nums.remove(0)
nums.extend([0]*i)

1比较是否相等数据元素在
while val in nums:
    nums.remove(val)

2排序
2.2nums1[m+n-1] = nums1[m-1] #最大的放到最后,从后面往前

*5数组的交集，可以重复*
一个一个比，两个指针，先排序
```

### *7退格字符串*

```python
def afterChange(s):
    res = ''
for i in s:
    if i == '#':
    res = '' if len(res) == 0 else res[:-1]  # 不能再往前如果没有字符。。res[:-1]:去掉最后一个
else:
res += i
return res
return afterChange(S) == afterChange(T)
```



### 3最大和的连续子数组（分治，DP）

暴力：两次循环

```python
3.1分治法

递归调用 max_left = self.maxSubArray(nums[0:len(nums) // 2])#递归计算左半边最大子序和
0127剑指经典-最大连续子序列的和
'''当前的最大值以及总的最大值。当累加的子数组和小于0的时候，放弃前面的子数组。总的最大值不用考虑那么多，直接每次都求最大就行。
一旦小于0，重新开始，，大于0加上前面的会更大，小于0加上只会更小'''
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if not array: return 0
        currSum, maxSum = 0, float('-inf')
        for num in array:
            currSum = num + currSum
            maxSum = max(currSum, maxSum)
            if currSum < 0:
                currSum = 0
        return maxSum
*3.2**动态规划*
动态规划,copy 只关注：当然值 和 当前值+过去的状态，是变好还是变坏;到i处的最大值两个可能，一个是加上a[i], 另一个从a[i]起头
maxSum = [nums[0] for i in range(n)]
for i in range(1,n):
    maxSum[i] = max(maxSum[i-1] + nums[i], nums[i])
```



### *4买卖股票相减最大值*

```python
#买入的数组copy :最大结尾-最小初始，两个临时变量进入循环
if not prices or len(prices) == 0:
    return 0
res, max_cur = 0, 0
for i in range(1, len(prices)):
    max_cur *= max(0, max_cur+prices[i]-prices[i-1])* 
后面数-最小,正就可以,变负数就有更小的初始: 如果正,,继续加后面两个差值:如果今天卖相比于昨天卖能多赚，则今天卖，否则之前就卖了
    res = max(res, max_cur)#曾经最大+现在新的大值比较
```



###  6*数组中的K-diff数对* 

### *双指针*

一旦遇到不是0的就把它往前移动-双指针

### *9数组；排序*

非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)

### *10**所有在 [1,* n**] 范围之间没有出现在数组中的数**

#### *集合相减*

 return list(set(range(1, len(nums)+1)) - set(nums))

### 11、**最大连续1的个数。**

12、return len(max(''.join(map(str, nums)).split('0'))) ：用0分隔取最大的个数

#### *map(function, iterable, …)*

将function应用于iterable的每一个元素

''.join(map(str, nums))

nums= [1,1,0,1,1,1]----》'110111'

### *13* 581 最短无序连续子数组.

先排序在比较

### 14、566. 重塑矩阵.

遍历到达长度后换行，两个【】数组变量

### 15、643 子数组最大平均数 I

f+=nums[i+k]-nums[i]#加一个，减一个，确定前面k个

### 16、605 种花问题

flowerbed = [0] + flowerbed + [0]  # 左右各加一个空位置
for i in range(1, len(flowerbed) - 1):  # 遍历出两端之外的位置
  if flowerbed[i - 1] == flowerbed[i] == flowerbed[i + 1] == 0:  # 遇到连续三个空位置
    flowerbed[i] += 1  # 放一盆花，改变值
    n -= 1  # 花数减一
  if n <= 0:  # 如果花用完了，返回True

 

### 17、661 图片平滑器

```python
def isLegal(self,x,y,i,j):
  return (True if((i<x)and(j<y)and(i>=0)and(j>=0)) else False)#是否存在

Filter=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]]#八个位置
遍历，存在相加
legalPointNum=0 #计数
graySum=0 #总和

for fi in range(9):#8个
    tmpi=i+Filterfi
    tmpj=j+Filterfi
    if(self.isLegal(x,y,tmpi,tmpj)):

```

### *18、665 非递减数列.py-去除一个成立*

nums[i] > nums[i+1]: x+=1如果x>1就不行

[1, 3 ,5 , 1 ,2 ]#只有x=1

if nums[i] > nums[i+1]:

​	if nums[i-1] > nums[i+1] and i+2 < len(nums) and nums[i] > nums[i+2]:#两次递增

 x+=1

​	如果x>1：return false 就不行

###  *19两个人城市距离调试*

```python
class Solution:
  def twoCitySchedCost(costs):
​    sum=0
​    a=0
​    b=0
​    for i in range(len(costs)):
​      if costs[i][0]<=costs[i][1] and a<len(costs)/2:
​        sum+=costs[i][0]
​        a+=1
​      elif costs[i][0]>costs[i][1] and b<len(costs)/
​        sum+=costs[i][1]
​        b+=1
​      if a==len(costs)/2:
​        sum+=costs[i][1]
​      elif b==len(costs)/2:
​        sum+=costs[i][0]
​    return sum
```

###         20剑指：出现1的个数（按照位数统计）

```python

```



## 1.2贪心算法0210

贪心和DP的比较：

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优上加以考虑，他所作出的是在某种意义上的局部最优解。贪心算法和动态规划算法都是由局部最优导出全局最优，这里不得不比较下二者的区别。

贪心算法：
1.贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不作保留；
2.由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。

动态规划算法：
1.全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解；
2.动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解；
3.边界条件：即最简单的，可以直接得出的局部最优解
————————————————
版权声明：本文为CSDN博主「负雪明烛」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/fuxuemingzhu/article/details/83504437

### 贪心算法解释

贪心算法（又称贪婪算法）是指，在对[问题求解](https://baike.baidu.com/item/问题求解/6693186)时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部[最优解](https://baike.baidu.com/item/最优解/5208902)。

***\*其实贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划\****

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关

### ***\*1\*******\*给定字符串\**** ***\*s\**** ***\*和\**** ***\*t\**** ***\*，判断\**** ***\*s\**** ***\*是否为\**** ***\*t\**** ***\*的子序列。\****

字符串可以分割，递归操作

self.isSubsequence(s[1:],t[i+1:])

### ***\*2分饼干-\*******\*满足越多数量的孩子\****

先排序，满足+1，不满足j+1

 

### ***\*3零钱问题\****

要计数零钱有多少，易错：还可以三张五元

然后向你付 5 美元、10 美元或 20 美元。

数组类似的变量：count=[0,0]计数就三个可能

### ***\*4方位问题\****

机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。

#### ***\*方位问题，最简单的思路就是建立一个数组存放\****up***\*、\****right***\*、\****down***\*和\****left

#### set(map(tuple, obstacles))

obstacles=[[2,4],[1,8]] -----》 {(1, 8), (2, 4)}

a= set(map(tuple, obstacles))

#### #四个方向x，y的步数

d = [(0, 1), (1, 0), (0, -1), (-1, 0)]#四个方向x，y的步数

#### 一步一步走d[tmp%4][0]

​        for _ in range(i):#每一步看是否障碍

​          x += d[tmp%4][0]

​          y += d[tmp%4][1]

### 5字母升序排列-sum(list(a) != sorted(a) for a in zip(*A)) #获取序列 zip(*A) ，不是升序就是1

### 6石头粉碎-排序后***\*提取\****石头打碎后放回排序

bisect.insort_left(stones, t1 - t2)

## 1.3双指针

~~~python
##双指针

- 19. Remove Nth Node From End of List
#两个指针p,q， q先走n步，然后p和q一起走，直到q走到结点，删除p.next解决。
#理解： 先走了n步，q始终在p前方n个，这样q走到末尾，p的下一个则是距离尾端n个的，画个图还是容易理解。


- 160. Intersection of Two Linked Lists
#如果两个linkedlist有intersection的话，可以看到，其实如果一开始我们就走到b2的话，
#那么我们就可以两个pointer一个一个的对比，到哪一个地址一样，接下来就是intersection部分。
#就一开始把长的那条list走掉多余部分。
#还有这里保证了是无环的状况

```
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
```


## 1快慢指针
- 141. Linked List Cycle
用两个指针，一个每次走两步，一个每次走一步，如果慢的最终和快的相遇，那么说明有环，否则没有环，直观的理解是如果两个跑的速度不一的人进操场跑步，那么最终慢的会追上快的.

## 2Reverse Linked List反转
- 206. Reverse Linked List
loop版本用prev, cur ,nxt 三个指针过一遍，recursion版本如下，可以再消化消化

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        return self.doReverse(head, None)
        
        
    def doReverse(self, head, newHead):
        if head == None:
            return newHead
        nxt = head.next
        head.next = newHead
        return self.doReverse(nxt, head)

##3寻找LinkedList中间项
#依旧使用双指针，快慢指针：快指针每次走两步，慢指针每次走一步，快指针如果到头了，那么慢指针也会在中间了，这个中间可以考量，如果是奇数的话必然是中间。
#如果是偶数则是偏前面的中间一项
```
1 -> 2 -> 3 -> 4: 2 
1 -> 2 -> 3 -> 4 -> 5 -> 6 : 3
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 : 4
```
#算法：
def findMid(head):
    if head == None or head.next == None:
        return head

    slow = head
    fast = head

    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
        
    return slow

~~~



### ***\*访问用字典记录\****

### ***\*1\*******\*判断链表中是否有环\****

双指针追赶***\*法\****

\#     while fast.next != None and fast.next.next != None:

\#       slow = slow.next

\#       fast = fast.next.next

### ***\*2回文链表\****

#### ***\*添加到数组中=-\*******\*空间复杂度就是O(n)\****

vals = []

vals += head.val,

数组反转

 vals == vals[::-1]

#### ***\*找到中间的节点，把linked list拆成两个部分\*******\*比较\****

#### ***\*#找到中间节点\****

​    while fast and fast.next:

​      fast = fast.next.next #两倍的速度

​      slow = slow.next

####     ***\*# 翻转后半部分\*******\*-head不断向后移动，head.next是前面一个数字\****

```py
def reverse_loop(head):
  if not head or not head.next:
​    return head
  pre = None 
  while head:
​    next = head.next  # 缓存当前节点的向后指针，待下次迭代用
​    head.next = pre  # 这一步是反转的关键，相当于把当前的向前指针作为当前节点的向后指针
​    pre = head# 作为下次迭代时的（当前节点的）向前指针，下次head.next=pr
​    head =next  # 作为下次迭代时的（当前）节点
  return pre   # 返回头指针，头指针就是迭代到最后一次时的head变量（赋值给了pre）

```



#### ***\*反转方法技巧\****

```py
    vowels = set(['a', 'u', 'e', 'i', 'o', 'A', 'U', 'E', 'I', 'O'])
​    p = [i for i in s if i in vowels]  # 去除元音
​    return ''.join([i if i not in vowels else p.pop() for i in s])  # 后面的先吐出来
\  # vowels = re.findall('(?i)[aeiou]', s) ?i忽略大小写
\  # return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s)
```

#### ***\*前后互换双指针\****



### ***\*8长按键\****

```python
 for j in range(len(typed)):
​   if i < name_len and typed[j] == name[i]:#j一直加，i看情况加
​        i += 1
​    elif j == 0 or typed[j] != typed[j-1]:
​        return False
```

## 1.4栈10.31

0315常用两个队列

```python
        
    def top(self):
        return self.stack[-1] #stack[-1]拿出顶部的
    def min(self):
        return self.minstack[-1]

```



### ***\*3、\*******\*20 有效的括号.py\****

match = {'{': '}', '[': ']', '(': ')'}  # 建立字典,pop出的和下一个非左边不对应

**if** match[top] != i: **return False**

### ***\*4、155. 最小栈.py\****

定义最小栈

```python
def push(self, x: int) -> None:
  self.stack.append(x)           # 把元素压入栈中
  if not self.min or x < self.min[-1]:   # 如果最小栈为空或新元素比基本栈的最小值还要小
    self.min.append(x)          # 该元素是目前出现的最小值，压入最小栈
  else:        self.min.append(self.min[-1])    # 将最小栈中的栈顶元素复制一遍压入最小栈,表示这时候最小是这个
```



5、225 用队列实现栈.py

```python
def init(self):
  self.stack = []
def push(self, x: int) -> None:
  self.stack.append(x)
def pop(self) -> int:
  return self.stack.pop(-1)
def top(self) -> int:
  return self.stack[-1]
def empty(self) -> bool:
  return self.stack == []
```



### ***\*5、496. 下一个更大元素.py\****

要一个栈来储存暂时没有遇到其更大元素的数。然后遍历nums2

 

遇到的数比栈中的某些元素大，则其为那些元素的下个更大数，然后将那些元素从栈中移除，存入哈希表中，并把最新遇到的数放入栈中

dic[stack.pop()] = n

**return** [dic.get(i, -1) **for** i **in** **nums1**] 

### ***\*6、503. 下一个更大元素 II.py\****

```python
res = [-1] * nums_len
for i in range(nums_len * 2):
  while stack and nums[stack[-1]] < nums[i % nums_len]:
    res[stack.pop()] = nums[i % nums_len]
```



## 1.5堆11.1

 https://blog.csdn.net/serenysdfg/article/details/104548350 (heap笔记）

### ***\*1、\*******\*703. 数据流中的第K大元素.py\****

**while** len(self.heap) > **k**:
  heapq.heappop(self.heap)  # 只保留最大的k个，可以弹出时就是第k大

### ***\*超级丑数\****

```python
while counter < n:
​      min = pow(2, 32)
​      for i in range(0, lenPrimes):
​        temp = dp[idxPrimes[i]] * primes[i]
​        if temp < min:
​          min = temp

​      for i in range(0, lenPrimes):
​        if min == dp[idxPrimes[i]] * primes[i]:
​          idxPrimes[i] += 1
​      dp.append(min)
​      counter += 1

 
```



​    

## 1.6 BST二叉树 ok0202 0307

### 0315

```python
996。腐烂橘子步数： #BFS 0315 先计算个数和已经腐烂位置 在开始腐烂，腐烂的向周围一步步找，记录步数

```



### 总结

#### 思路：从子树开始考虑

 \#先写第一个再逐步递归，进入状态，找方法

 具体是使用自底向上还是自顶向下的方式取决于，当前的节点需不需要其子节点或者是子树的结果 

 https://tding.top/archives/101cdf53.html  优秀

 https://juejin.im/post/5d56fb6ff265da03e4675be4 

#### 常考整理

**平衡二叉树**： 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 

**二叉查找/搜索/排序树**：当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大**。

完全二叉树： 完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。 

满二叉树： ：每一个结点要么度为0（是叶子结点），要么度为2（有2个孩子结点）。 

**红黑树：** 属于AVL树（平衡二叉查找树）的一种，对树的高度的要求不如AVL树那么严格（不是严格控制左、右子树高度或节点数之差小于等于1），使得其插入结点的效率相对更高。 

- - 遍历(Traversal)问题
    - [先序、中序与后序遍历](https://blog.csdn.net/qq_32690999/article/details/80484440#先序中序与后序遍历)
    - [利用两种遍历结果构造二叉树](https://blog.csdn.net/qq_32690999/article/details/80484440#利用两种遍历结果构造二叉树)
  - 递归问题
    - [二叉树最大深度](https://blog.csdn.net/qq_32690999/article/details/80484440#二叉树最大深度)
    - [二叉树最小深度](https://blog.csdn.net/qq_32690999/article/details/80484440#二叉树最小深度)
    - [平衡二叉树判断](https://blog.csdn.net/qq_32690999/article/details/80484440#平衡二叉树判断)
    - [相同树](https://blog.csdn.net/qq_32690999/article/details/80484440#相同树)
    - [对称树](https://blog.csdn.net/qq_32690999/article/details/80484440#对称树)
    - [路径总和](https://blog.csdn.net/qq_32690999/article/details/80484440#路径总和)
  - 二叉搜索树/排序树问题
    - [验证二叉搜索树](https://blog.csdn.net/qq_32690999/article/details/80484440#验证二叉搜索树)
    - [唯一二叉搜索树](https://blog.csdn.net/qq_32690999/article/details/80484440#唯一二叉搜索树)
    - [最低的二叉树共同祖先](https://blog.csdn.net/qq_32690999/article/details/80484440#最低的二叉树共同祖先)

#### 理论

      - [x] 插入
            • 如果树为空，创建一个叶子节点，令该节点的key = k;
            • 如果k小于根节点的key，将它插入到左子树中;
            • 如果k大于根节点的key，将它插入到右子树中。
      - [x] 遍历
            • 前序:  根，左，右  • 中序：左，根，右 **有序** • 后序：左，右，根
      - [x] 搜索
            - look up ： 是否存在
              • 如果树为空，搜索失败;
              • 如果根节点的key等于待搜索的值，搜索成功，返回根节点作为结果;
              • 如果待搜索的值小于根节点的key，继续在左子树中递归搜索;
              • 否则，待搜索的值大于根节点的key，继续在右子树中递归搜索。	
            - 最大元素和最小元素
              	• 最右和最左
            - 前驱(Successor)和后继(predecessor)
              	给定元素x，它的后继元素y是满足y > x的最小值
              		• 如果x所在的节点有一个非空的右子树，则右子树中的最小值就是答案
              		• 否则我们需要向上回溯，找到最近的一个祖先，使得该祖先的左侧孩子，也为x的祖	先。
      - [x] 删除
               • 如果x没有子节点，或者只有一个孩子，直接将x“切下”;
               • 否则，x有两个孩子，我们用其右子树中的最小值替换掉x，然后将右子树中的这一最小值“切掉”。
#### 杂

```python
####返回null return [None]

####防止重新变成空
    if not t:return ""
    a=[]
    def dp(t):
        a.append(str(t.val))
        。。。。
        return ''.join(i for i in a)
    result=dp(t)
    return result

resMap[root.val] = resMap.get(root.val, 0) + 1 #计数，默认0

#### 高度
def maxDepth(self, root: TreeNode) -> int:
    return 0 if not root else max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 #递归+1，最下面的节点是root加上就好


```

#### 各种遍历递归与非递归0403（还要加强记忆

 https://blog.csdn.net/serenysdfg/article/details/105303023 



#### 中序遍历-递归和非递归

```python
result=[]
inorder(root,result)
def inorder(self,root,result):
    if root :
        self.inorder(root.left,result)
        result.append(root.val)
        self.inorder(root.right,result)

def middle(self, root):#中序遍历
    if not root:
        return
    self.middle(root.left)
    self.mid.append(root)
    self.middle(root.right)
#简便写法 
 def dfs(self, root):
    if root == None:
        return []
    return self.dfs(root.left) + [root.val] + self.dfs(root.right)#中序遍历
```
##### 非递归

```python

class Solution:
            #2非递归中序遍历:重点
    def KthNode(self, pRoot, k):
        if k <= 0 or not pRoot:
            return None
        ##非递归开始
        stack, res = [], []
        pNode = pRoot
        while pNode or len(stack):
            while pNode:
                stack.append(pNode) #保存根+进入左边
                pNode = pNode.left
            if: 
                node = stack.pop()
                res.append(node) #添加最左边,node也可以写成pnode
                pNode = node.right# 最左边的右边，最左边就是根（根右）#p=node注
        ##非递归结束
        if k > len(res):
            return None
        return res[k-1]
            res.append(node.val)#添加左边--根
        node = node.right#左边的右子节点 有上面就是跟-右，没有就是左-跟
```



####    前序遍历


```python
def preorderTraversal(self, root: TreeNode) -> List[int]:
    self.res=[]
    self.preorder(root)
    return self.res
def preorder(self,root):
    if not root:return []
    else:
        self.res.append(root.val)
        self.preorder(root.left)
        self.preorder(root.right)
#2
      
def preorder(root):
    res = []
    if not root:return res
    res.append(root)
    if root.left: 
        res.extend(preorder(root.left))
    if root.right:
        res.extend(preorder(root.right))
    return res

```



#### 根据遍历构建二叉树

```python
    def Deserialize(self, s):
        vals = deque(val for val in s.split())
        def build():
            if vals:
                val = vals.popleft()
                if val == '#':
                    return None
                root = TreeNode(int(val))
                root.left = build()#左边建好到None为止
                root.right = build()
                return root
        return build()

```

### 重建二叉树-剑指

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder: #注意
            return None
        root=TreeNode(preorder[0])
        i=inorder.index(root.val)

        root.left=self.buildTree(preorder[1:i+1],inorder[:i]) #递归控制
        root.right=self.buildTree(preorder[i+1:],inorder[i+1:])
        return root
```

### 108建造树

```python
# 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:return None #重要
        #左右相等就会高度平衡
        mid=len(nums)//2
        root=TreeNode(nums[mid])
        root.left=self.sortedArrayToBST(nums[:mid])
        root.right=self.sortedArrayToBST(nums[mid+1:])
        return root
```



### 题543. 二叉树的直径

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


# me左右最长相加dfs  copy不太会这一类题目
class Solution:
    def __init__(self):
        self.res = 0

    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def dp(root):
            if root == None:return 0
            x = dp(root.left)
            y = dp(root.right)
            self.res = max(x + y, self.res)  # 获取全部更大返回的x已经+1
            return max(x, y) + 1  # 内部返回左右数更大一个+到这个节点

        dp(root)
        return self.res 

```

### 563. 二叉树的坡度

```python
class Solution:
    def findTilt(self, root: TreeNode) -> int:
        def sum_and_tilt(root):
            if not root: #1not root
                return 0, 0
            sum_left, tilt_left = sum_and_tilt(root.left) #2递归
            sum_right, tilt_right = sum_and_tilt(root.right)
            #3返回结果
            return sum_left + sum_right + root.val, abs(sum_left - sum_right) + tilt_left + tilt_right
 
        sum_tree, tilt_tree = sum_and_tilt(root)
        return tilt_tree
```

### 637二叉树的层平均值

```python
def averageOfLevels(self, root: TreeNode) -> List[float]:
    if not root: return []                                   # 如果输入空树，直接返回空列表
    cur_layer = [root]                              # 根节点放进当前层列表
    res = []                                        # 结果列表，存放各层均值
    while cur_layer:                                # 当前层不为空时，执行
        res.append(sum(node.val for node in cur_layer) / len(cur_layer))  # 将当前层结点平均值添加到结果中
        next_layer = []                             # 当前层结点列表初始化为空
        for node in cur_layer:                      # 遍历上一层结点列表中的各个结点
            if node.left:                           # 如果存在左子树
                next_layer.append(node.left)        # 添加左孩子到下一层列表
            if node.right:                          # 如果存在右子树
                next_layer.append(node.right)       # 添加右孩子到下一层列表
        cur_layer = next_layer                      # 更新上一层结点列表
    return res   
```

### 572. 另一个树的子树

#### 先序列化-包含

```python
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def pre_order(root, res):
            if root:                            # 如果当前节点不为空
                res.append(str(root.val))       # 添加当前结点的值
                pre_order(root.left, res)       # 左子树的前序遍历
                pre_order(root.right, res)      # 右子树的前序遍历
            else:                               # 如果当前结点为空
                res.append('#')                 # 用“#”代替
        s_list, t_list = [], []                 # 序列化结果存储器
        pre_order(s, s_list)                    # 获取s的前序遍历结果
        pre_order(t, t_list)                    # 获取t的前序遍历结果
        return ','+','.join(t_list) in ','+','.join(s_list)

class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        toTup = lambda n: (n.val, toTup(n.left), toTup(n.right)) if n else None# 这个函数把树序列化为一个元组
        return str(toTup(t)) in str(toTup(s))# 把元组转化为字符串以方便比较
```

### 589. N叉树的前序遍历-重要

```python
#递归法
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        #递归
        list =[]
        if not root:  return list #没有了就返回list
        else:
            list.append(root.val) 
            for i in root.children:#root.children
                list.extend(self.preorder(i))
        
        return list
#2迭代法：迭代法即使用循环，循环结束时，输出结果。典型的迭代法为二叉树的层序遍历，使用队列来保存节点。
class Solution(object):
    def preorder(self, root):
        if not root: return [];
        stack = [];
        result = [];
        stack.append(root);
        while stack:
            curr = stack.pop();
            result.append(curr.val);#根
            if curr.children:
                curr.children.reverse();#要反转后面的放到前面的放到最后推入pop，左边先遍历
                stack += curr.children;
        return result;
```

### 590.N叉树的后序遍历

```python
def postorder(self, root: 'Node') -> List[int]:
    list =[]
    if not root:
        return list #没有了就返回list
    else:       
        for i in root.children:#root.children
            list.extend(self.postorder(i))
        list.append(root.val) 

    return list
# #2迭代法：迭代法即使用循环，循环结束时，输出结果。典型的迭代法为二叉树的层序遍历，使用队列来保存节点。
def postorder(self, root: 'Node') -> List[int]:
    result = []
    if not root:
        return result
    temp = []
    temp.append(root)
    while temp:
        node = temp.pop() #节点出来后
        result.insert(0, node.val)#根节点放在最前面节点后面
        if len(node.children) > 0:
            for n in node.children:
                temp.append(n) #第一个子节点，第二个，第三个。。的孩子

    return result

        
```

### 经典题-剑指offer0122  二叉树中和为某一值的路径 

 FindPath2(root, path, currentNum)  现在的指，满足条件

递归弹出

```python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#比较好
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        if not root: #不存在
            return []
        result = []

        def FindPath2(root, path, currentNum):
            #两个变量变化
            currentNum += root.val
            path.append(root) #path 和 currentNum 对应，临时变量
            
            flag = root.left == None and root.right == None  #flag=1，叶子节点，
            if currentNum == expectNumber and flag:#是叶子节点 并且 符合要求  进入结果
                onepath = []
                for node in path:
                    onepath.append(node.val)
                result.append(onepath)

            if currentNum < expectNumber: #递归
                if root.left:
                    FindPath2(root.left, path, currentNum)#加到左边
                if root.right:
                    FindPath2(root.right, path, currentNum)
            # 拿到一个正确的路径后要弹出，回到上一次父节点继续递归
            path.pop()

        FindPath2(root, [], 0)
        return result
```

### 01月28剑指1：二叉树的最大深度

```python
class Solution:
    def TreeDepth(self, pRoot):
        if not pRoot: return 0 #要先返回
        return max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right)) + 1
```

### 111最小深度

```python
    # 找到最近的叶子节点，容易失误：根节点如果只存在左子树或者只存在右子树，则返回值应为左子树或者右子树的（最小深度+1）。,两行重要
def minDepth(self, root: TreeNode) -> int:
    if not root: return 0
    elif not root.left:return self.minDepth(root.right) + 1
    elif not root.right: return self.minDepth(root.left) + 1
    return min(self.minDepth(root.left),self.minDepth(root.right)) + 1

```





### 难记：剑指2-110平衡二叉树

 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵*平衡二叉树*。 

```python
'''输入一棵二叉树，判断该二叉树是否是平衡二叉树。'''
class Solution:
    def IsBalanced_Solution(self, pRoot):
        self.flag = True
        self.tree_Iteration(pRoot)
        return self.flag

    def tree_Iteration(self, pRoot):
        if not pRoot or self.flag==False:
            return 0
        left = self.tree_Iteration(pRoot.left)
        right = self.tree_Iteration(pRoot.right)
        if abs(left-right)>1:
            self.flag = False
        return max(left, right) + 1
```

2

```python
def isBalanced(self, root: TreeNode) -> bool:
    if not root :return True
        return abs(self.maxDepth(root.left)-self.maxDepth(root.right))<=1 and self.isBalanced(root.left) and self.isBalanced(root.right) #每个节点

def maxDepth(self,root):
    if not root:return 0
    return  max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```



### 100相同的树

```python
def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
    # copy # 递归左右节点，内容相同
    if p and q:
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right) 
    if p == None and q == None:   return True
    else:  return False
```

### 101对称二叉树

都没有子节点对称，一个没有不对称，递归

```python
def isSymmetric(self, root: TreeNode) -> bool:
    if not root: return True
    return self.subSym(root.left,root.right)
def subSym(self,left,right):
    if not left and not right: return True
    elif not left or not right: return False
    elif left.val==right.val:
        return self.subSym(left.left,right.right) and  self.subSym(left.right,right.left)
    return False
```

### 235 二叉搜索树的最近公共祖先

节点==root或者在他左右，root就是祖先    递归

```python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    if not root or root == p or root == q:return root#不是返回none其他两种情况
    elif p.val < root.val < q.val or q.val < root.val < p.val :return root
    elif p.val < root.val and q.val < root.val: #在左边继续找
        return self.lowestCommonAncestor(root.left,p,q)
    else:
        return self.lowestCommonAncestor(root.right,p,q)
```

### 257 二叉树的所有路径

到节点接入，没到递归

```python
def binaryTreePaths(self, root):
    def helper(node, cur_path):
        if not node.left and not node.right:  ## 到leaf了
            res.append(cur_path + [node.val])
            return
        if node.left:
            helper(node.left, cur_path + [node.val])
        if node.right:
            helper(node.right, cur_path + [node.val])

    res = []
    if not root: return res
    helper(root, [])
    return ['->'.join([str(val) for val in path]) for path in res]  # res存储很多path
```

### 112路径总和

是否存在路径和=sum   不断递归减

```python
def hasPathSum(self, root: TreeNode, sum: int) -> bool:
    if not root:  return False
    
    if root.left or root.right:
        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
    else:
        return root.val == sum
```

### 113路径总和2 

满足条件加入 subPathsum(root,sum,curlist,reslist)  ,curlist临时reslist结果  (curlist + [root.val])

```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        res=[] #获取结果
        self.subPathsum(root,sum,[],res)
        return res
    def subPathsum(self,root,sum,curlist,reslist):#单个，全部list
        if not root:return []
        if root.val==sum and not root.left and not root.right:#叶子节点
            reslist.append(curlist + [root.val])
            return  #return就是cur_lists就是res的意思
        if root.left:
            self.subPathsum(root.left,sum-root.val,curlist+[root.val],reslist)
        if root.right:
            self.subPathsum(root.right,sum-root.val,curlist+[root.val],reslist)

```

### 98. 验证二叉搜索树

```python

def isValidBST(self, root: TreeNode) -> bool:
    return self.isBST(root, float('-inf'), float('inf'))

def isBST(self, root, minKey, maxKey): #先判断子树
    if root == None: return True
    if root.val <= minKey or root.val >= maxKey: return False
    return self.isBST(root.left, minKey, root.val) and self.isBST(root.right, root.val, maxKey) #root.left.val>=root.val
```

### 235二叉搜索树的最近公共祖先（多做

```python
def lowestCommonAncestor(root,p,q) :
    if root==p or root==q or not root or  p.val<root.val<q.val or p.val>root.val>q.val :return root #返回p或者q在root下的节点
    elif p.val<root.val:
        return self.lowestCommonAncestor(root.left,p,q) #要用return
    elif p.val>root.val:
        return self.lowestCommonAncestor(root.right,p,q)
```

### 0306思路

```
翻转递归
左右都递归(从最小开始想起)1026不太会 祖先（235，236，2016
```

## 1.7 Dfs深度优先0209

### 时间复杂度

BFS和DFS都是：

邻接矩阵-O(n^2)

邻接表-O(n+e)

0315

DFS用visited一般直接整个用dfs带入

1、DFS+栈：pop和visited结合，没访问的append，然后一个个pop

2、dfs一般自己向下不断递归调用，返回一般返回最底层

```
for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
    next_i, next_j = cur_i + di, cur_j + dj
```

分割问题很多

```python
def dfs(i,j,image,visited): #有变化的要放进去image，visited
    if  0<=i<col and  0<=j<row and image[i][j]==origin  and not visited[i][j] :
        visited[i][j]=1
        image[i][j]=newColor
        for d in dire:
            dfs(i+d[0],j+d[1],image,visited)
dfs(sr,sr,image,visited)
```

看来，DFS与BFS是算法道路上最基础最容易掌握的，同时，又能提供巨大助力的方法之一

深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。

否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。

广度优先搜索旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作

***\*1.数据结构上的运用\****

DFS用递归的形式，用到了栈结构，先进后出。

BFS选取状态用队列的形式，先进先出。

***\*2.复杂度\****

DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。

***\*3.思想\****

思想上来说这两种方法都是穷竭列举所有的情况

 10.9位运算不太懂11.3

## 1.8  BFS广度优先搜索 0209

复杂一点时间太久

#### 常用

 一般来说DFS需要有固定的起点

​    neighbors = collections.defaultdict(set)#set

​    for u, v in edges: #无向图

​      neighbors[u].add(v)

​      neighbors[v].add(u)

广度

```python
for child in employee.subordinates:    
    importance += dfs(infos[child], infos)
#2递归
    def dfs(self, visited, matrix, m, n, i, j):#全部能下去的
        visited[i][j] = True
        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        for dire in directions:
            x, y = i + dire[0], j + dire[1]
            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or matrix[x][y] < matrix[i][j]:
                continue #没参观过,所有周围比这小的
            self.dfs(visited, matrix, m, n, x, y) #重要满足条件每一个都要
            
def bfs:
     while q:
        v = q.popleft()#every point
        for e in graph[v]:#every edge
            if visited[e] != 0:#参观过
                if visited[e] == visited[v]:
                    return False
            else:
                visited[e] = 3 - visited[v]#相反颜色
                q.append(e)
```

visited[i] [j]

字符串改变：next_node = node[:i] + str((int(node[i]) + j) % 10) + node[i + 1:] 

 BFS的特点：优先搜索离根节点近的节点， 所以用BFS来处理 

dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]

```python
if not root:
    return False
q, seen = [root], set()
for i in q:
    if k - i.val in seen:
        return True
    seen.add(i.val)
    if i.left:
        q.append(i.left)
    if i.right:
        q.append(i.right)
return False

#2
 
while queue:
    node, cnt = queue.pop(0) #取一个点出来，cnt是当前走的步数
    if node == target: #找到了
        return cnt     

    for i in range(4):
        for j in [1, -1]:
            next_node = node[:i] + str((int(node[i]) + j) % 10) 

            if next_node not in deadends: #判断后操作
                deadends.add(next_node) #避免重复
                queue.append([next_node, cnt + 1])
return -1

```

### 130经典BFS

工具：

```
visited[i] [j]

row = len(board)
col = len(board[0]) if row else 0
visited = [[0 for i in range(col)] for j in range(row)]

dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]

for d in dirs:
    if legal(x+d[0],y+d[1]):
        s.append((x+d[0],y+d[1]))

def legal(x,y):
            return x>=0 and x < row and y>=0 and y < col and board[x][y] == 'O' and visited[x][y] == 0
```



def legal(x,y):
return x>=0 and x < row and y>=0 and y < col and board[x][y] == 'O' and visited[x][y] == 0 #合法且没有被参观过的O

```PYTHON
while s:
    (x,y) = s.pop()
   # if x == 0 or x == row - 1 or y == 0 or y == col -1 :
    #    shouldChange = False
    visited[x][y] = 1
    Oarea.append((x,y))
    dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]
    for d in dirs:
        if legal(x+d[0],y+d[1]):
            s.append((x+d[0],y+d[1]))
return Oarea,shouldChange #visited输出可以不用重复

def legal(x,y):
return x>=0 and x < row and y>=0 and y < col and board[x][y] == 'O' and visited[x][y] == 0 #合法且没有被参观过的O
```



## 1.9链表-哈希字典 11.4

dummy，prev，cur

转整数：先变成链表，str  或者遍历一个*10+val

技巧：用index序号，链表中位置

### 总结

画图重要

复杂度： https://tding.top/archives/551df4d4.html 

#### 1技巧

 1**使用 dummy node**：dummy node 就是在链表的 head 前加一个节点指向 head ， 特别适合用在链表的 head 发生变化的情况下，如删除或被修改等

 `dummy`大法对于`nodeList`的题目简直无敌！！ 

 2**双指针法**：对于寻找链表的某个特定位置，或者判断是否有环等问题时，可以用两个指针变量 fast 和 slow，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止。 

```
slow = head
fast = head
```

3 **交换节点的处理**：如果需要交换两个节点的位置，对于这两个前驱节点，他们的 next 指针会受到影响 

- 先交换两个前驱节点的 next 指针的值
- 再交换这两个节点的 next 指针的值



**low，fst双指针**，因为链表无法得知长度，所以尝试用这种方法来达到某种效果（长度、检测环等）
使用一些**临时变量**来存储next指针，以完成插入删除等操作
对一些依赖于后面节点才可以完成的操作，使用**递归**的方式来解决
对于有些题目提前使用循环**获得其链表的长度**也是一种有效的方法
对于要考虑最后几个节点的操作，有事可以再遍历之前先将头指针向后移动k个节点
插入、删除操作往往需要使用目标节点前面的节点，所以往往会**定义一个新的链表节点其next指针指向head节点**

#### 2题目类型-链表的基本操作类题目

- 删除链表中的节点
  - [203 - 移除链表元素](https://tding.top/archives/551df4d4.html#203-移除链表元素)
  - [237 - 删除链表中的节点](https://tding.top/archives/551df4d4.html#237-删除链表中的节点)
- 合并链表
  - [21 - 合并两个有序链表](https://tding.top/archives/551df4d4.html#21-合并两个有序链表)
  - [23 - 合并 k 个排序链表](https://tding.top/archives/551df4d4.html#23-合并k个排序链表)
- 分隔链表
  - [86 - 分隔链表](https://tding.top/archives/551df4d4.html#86-分隔链表)
- 交换链表
  - [24 - 两两交换链表中的节点](https://tding.top/archives/551df4d4.html#24-两两交换链表中的节点)
- 旋转链表
  - [61 - 旋转链表](https://tding.top/archives/551df4d4.html#61-旋转链表)
- 链表排序
  - [143 - 重排链表](https://tding.top/archives/551df4d4.html#143-重排链表)
  - [147 - 对链表进行插入排序](https://tding.top/archives/551df4d4.html#147-对链表进行插入排序)
  - [148 - 排序链表](https://tding.top/archives/551df4d4.html#148-排序链表)

#### 常用代码

```python
dummy = ListNode(-1)
dummy.next = head
cur = dummy.next  # head
```



### 0127建立双向链表

```python
for i in range(len(self.mid)-1):#建立链表
    self.mid[i].right = self.mid[i+1]
    self.mid[i+1].left = self.mid[i]
```

删除链表中的节点

### 206反转链表

```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head

        while cur != None: #两个两个指针变化
            temp = cur.next #1拿出下一个节点，2然后反转，3移动指针
            cur.next = pre
            pre = cur #重要一直向后移动
            cur = temp

        return pre

        
        

```



### 203 - 移除链表元素

```python
'''删除链表中等于给定值 val 的所有节点。'''
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        cur = dummy

        while dummy.next:
            if dummy.next.val == val:
                dummy.next = dummy.next.next
            else:
                dummy = dummy.next
        return cur.next
```



### 237 - 删除链表中的节点

注意如果删除的是末尾节点，本题未考虑

```python
class Solution:
    def deleteNode(self, node):
        node.val=node.next.val#更改val和next
        node.next=node.next.next
```

### 82删除排序链表中的重复元素 II

```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        cur = dummy.next  # head
        nodeNumber = {}
        while cur:  # 构建字典
            nodeNumber[cur.val] = nodeNumber.get(cur.val, 0) + 1
            cur = cur.next
        cur = dummy
        while cur.next:
            if nodeNumber[cur.next.val] > 1:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy.next

##2自己的思路

    class Solution:
        def deleteDuplicates(self, head: ListNode) -> ListNode:
            h = ListNode(-1)
            h.next = head
            pre = h
            cur = head
            while cur != None:
                duplicate = False
                while cur.next != None and cur.val == cur.next.val:
                    cur = cur.next
                    duplicate = True
                if duplicate == False: pre = cur
                else: pre.next = cur.next  # 直到不重复
                cur = cur.next
            return h.next
```



### 83删除排序链表中的重复元素

```python
def deleteDuplicates(self, head: ListNode) -> ListNode:
    dummy = head
    while head:
        while head.next and head.next.val == head.val:
            head.next = head.next.next
        head = head.next  
    return dummy
```

合并链表

### 21 - 合并两个有序链表

```python
def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
    if l1 == None: return l2
    if l2 == None: return l1
    dummy = ListNode(-1)
    cur = dummy
    while l1 and l2:
        if l1.val <= l2.val:
            cur.next = l1
            l1 = l1.next
        else:
            cur.next = l2
            l2 = l2.next
        cur = cur.next
    if l1 == None:
        cur.next = l2
    else:
        cur.next = l1
    return dummy.next
```

### 23 - 合并 k 个排序链表

```python
def mergeKLists(self, lists: List[ListNode]) -> ListNode:
    k = len(lists)  # k长度
    if k == 0: return None
    interval = 1
    # 两两合并:重点难点
    while interval < k:
        for i in range(0, k, interval * 2):  # (0,3,1*2)  (0,3,2*2)
            # 最后落单的链表直接保留
            if i + interval < k:  # 3<k不成立  0和2，4和6
                lists[i] = self.mergeTwoLists(lists[i], lists[i + interval])  # list(0),list(2),list(4)
        interval *= 2

    return lists[0]

```

分隔链表

### 86 - 分隔链表-链表分化

```python

def partition(self, head: ListNode, x: int) -> ListNode:
    if head == None or head.next == None:
        return head

    cur = head
    pre_min = cur_min = ListNode(-1)
    pre_max = cur_max = ListNode(-1)
#最简单的思路就是两个dummy head，然后一个指向 小于的node，一个指向大于的node
    while cur != None:
        if cur.val < x:
            cur_min.next = cur
            cur_min = cur_min.next
        else:
            cur_max.next = cur
            cur_max = cur_max.next

        cur = cur.next

    cur_min.next = pre_max.next
    cur_max.next = None
    return pre_min.next
```

交换链表

### 24 - 两两交换链表中的节点

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if not head or not head.next:return head
        #交换
        tmp = head.next
        head.next = self.swapPairs(head.next.next) #下一个先把后面的置换 #递归重要
        tmp.next = head
        return tmp
    ##2
def swapPairs(self, head: ListNode) -> ListNode:
    if head == None or head.next == None: return head

    dummy = ListNode(-1)
    dummy.next = head

    cur = dummy

    while cur.next and cur.next.next:  # 有两个 两个变换
        next_one, next_two, next_three = cur.next, cur.next.next, cur.next.next.next  # 3 4 5
        cur.next = next_two  # 2
        next_two.next = next_one  # 2->1->3->4
        next_one.next = next_three
        cur = next_one  # cur=1
    return dummy.next
```

旋转链表

### 61 - 旋转链表

```python
def rotateRight(self, head: ListNode, k: int) -> ListNode:
    if head == None or head.next == None:  return head

    pre = head
    count = 1
    while pre.next != None:
        count += 1
        pre = pre.next
    pre.next = head#先变成圆
    
    n = count - k%count
    end = pre
    for _ in range(n):
        end = end.next#到达最后切断
    new_head = end.next
    end.next = None
    return new_head
```

链表排序

### <u>*143 - 重排链表（旋转链表重要*</u>

```python
    def reverseList(self, head):   #三个指针：当前cur，前面pre，后面next
        prev = None
        cur = head 
        while (cur): #1
            nxt = cur.next  #获取下一个节点，下一轮后面的元素要指向它
            cur.next = prev #翻转
            prev = cur #prev=1 2
            cur = nxt #cur=2 3
        return prev
```

### 147 - 对链表进行插入排序

```python
def
```

### 148 - 排序链表

```python
def
```



### 0126链表复制常用

```python
# first step, N' to N next 把next复制给新串
while dummy:
    dummynext = dummy.next
    copynode = RandomListNode(dummy.label)
    copynode.next = dummynext
    dummy.next = copynode
    dummy = dummynext
dummy = pHead
```



### 代码

```
l1 = l1.next if l1 else None#l1 = l1.next if l1 else Non
```



### 典型-83删除有序链表重复元素

```python
dummy = head
while head:
    while head.next and head.next.val == head.val:
        head.next = head.next.next  # skip duplicated node #有排序
    head = head.next  # not duplicate of current node, move to next node
return dummy
```

### 典型2 203. 移除链表元素

 删除链表中等于给定值 ***val\*** 的所有节点。 

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#简单
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        #copy
        dummy = ListNode(-1) #重要前面加一个
        dummy.next = head
    
        cur = dummy
    
        while cur.next:#cur用于循环
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
    
        return dummy.next
       # Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#简单
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        #copy
        dummy = ListNode(-1) #重要前面加一个
        dummy.next = head
    
        cur = dummy
    
        while cur.next:#cur用于循环
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
    
        return dummy.next
       
```

用set和dict

 *哈希*映射- 用法*哈希*映射是用于存储(key, value) 键值对的一种实现 

```python
	class ListNode(object):
	    def __init__(self, x):
	        self.val = x
	        self.next = None      
	node1 = ListNode(1)
	node2 = ListNode(2)
	node3 = ListNode(3)
	
	node1.next = node2
	node2.next = node3
#删除
	def deleteNode(node):
	    while node.next:
	        node.val = node.next.val
	        node = node.next
	    node = None
    
	deleteNode(node4)
```

```python
#有的时候因为边界条件，需要判定是否是list的head，因为处理起来会有些不同，而创造一个dummy head则可以极大的解决一些问题。
pythondummy = ListNode(-1)
dummy.next = head
```

### 953. 验证外星语词典-利用zip和key

```python
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
          #copy1
        # return words == sorted(words, key=lambda x: list(map(order.index, x))) #根据order排序后是不是相同 
        #copy2
        order = {c:i for i, c in enumerate(order)}
        
        for word1, word2 in zip(words, words[1:]): #利用zip
            for a,b in zip(word1, word2):
                if a != b:
                    if order[a] > order[b]:
                        return False
                    break
            else:
                if len(word1) > len(word2):
                    return False
        return True

```



```python
 return words == sorted(words, key=cmp_to_key(lambda x, y:helper(x, y)))
使用def helper
```



## 1.10字符串

字母不同问题用set

```python

x = ''.join(sorted(list(i)))#转换相同的
 
i.lower() for i in a
string.count('a') #返回str在string里面出现的次数
''.join(s)
s=list(s) #数组和list转换
 
变成list、 s[end], s[start] = s[start],s[end]#互换
 
#排序
sorted(logs, key = f)#参考937. 重新排列日志文件  key=(0, rest, id_)分为多个优先级
sorted(words, key=lambda x: list(map(order.index, x))) #排序key
 
'1'.isdigit() #数字 #判断类型
'1'.isalpha()
str.isdigit(ch):
    
a=[]  a.append('a')  
 #字符串连接
''.join(i for i in a)
a='' a+='4'
 
[i.count(min(i)) for i in queries] #计算
''.join(i for i in s)  
 
s.find(' ')  #找字符
s.index('c') #返回第一个位置
str=str.replace('a', 'e')#改变值，去掉符号等，不支持部分切片转换
string.count('a')  ##返回str在string里面出现的次数
 
''.join(reversed(res)) #字符串连接#常用
 for  i in s: #字典
    dict[i]+=1
    
[::-1]#反转
num1[-i]#字符从后往前
res[:-1]:去掉最后一个
 
字符串不能赋值，但是可以定位S[0]
字符串数组用sorted
str.strip()#去掉空格
sum(nums[i:i+k]) #数组计算总和用
 #{字符：顺序}Enumerate
order = {v: i for i, v in enumerate(arr2)}
Range从大到小-range(len(A),1，-1):
 
###### ***\*Counter\****
from collections import Counter
c = Counter('abcasd')#字典
 A ==B: #字符串相等
   
path.split('/')#要分隔  
log.split(" ", 1) #分成两个。如果存在参数num，则仅分隔成num+1 个子字符串 #split
 
str=str.upper() #转换成大写
str=str.lower() #转换成小写
islower()  /isupper() #判断是否是大小写
ord #转 换
 
s[3:9]:9超出也可以
 
ord（num[0]）-ord('a')

order = "hlabcdefgijkmnopqrstuvwxyz"
{c:i for i, c in enumerate(order)}

'''
for a, b in itertools.izip(A, B):
dic = zip(A,B)
for i,j in dic.items():'''

```

概念：回文，子串，子序列，前缀树，后缀树，匹配（重要indexof），字典序

操作增删改查，替换，旋转

1guize 判断 2数字int等大整数

排序调整（快速排序、字符计数哈希，滑动窗口

5最长公共子串，回文子串，回文子序列，bfs、dfs

旋转，拼接最小字典序

### 0321思路整理看题总结

```python
#先获取最大，先sort，用index等方法，先copy（反转相关）
   '''字典法：'''
242判断异位词：
'''指针法：--善于利用'''
415字符串相加：carry += ord(num1[i]) - ord('0') #转化ascii

'''#规律题目'''
520大写字母问题：规律，几个大写，如果大写会怎样
521最长特殊序列 
686重复叠加字符串匹配：最多复制两次

'''子串'''
696：二进制01个数相同的子串数.指针计数法：规律 ：辅助min(group[i],group[i+1])


字符串的最大公因子：数学：约数，最大公约数 、辗转相除法
#答案肯定是字符串的某个前缀，暴力：枚举所有的前缀来判断 range(min(len(str1), len(str2)), 0, -1)，除以前缀长度余数是0
字符遍历：用while计数，if判断
9数字回文：1变成字符串翻转（python）2指针左右 3: 数组从个位乘回去
13罗马数字转：字典，然后比较字符左右大小，加上字典对于的，IV 已经加了1要减去两倍
14 最长公共前缀：排序选择最短，最短循环和其他比，不满足就减一
15字符串二进制求和：循环三者一起，一位一位计算
只考虑字母数字：cisalnum(): #判断字符变量c是否为字母或数字

有时候先倒过来处理 482密钥格式化

443压缩字符串a2b3c:要有一个index指针记录从哪个开始#chars[index:end] = [chars[index]] + list(str(count)) #单个字母就不加count
459重复子串：#长度循环后计算相乘满足返回true：长度1  *（len）//1  2*(len//2)
541字符串反转k个转k个不转：#遍历添加元素
657机器人一点，两个数值方向变化a=[0,0]
686字符串叠加：

```

### 进位+相加常用 415字符串相加

```python
        i = len(num1) - 1
        j = len(num2) - 1
        result = ''
        carry = 0
        while i >= 0 or j >= 0:
            if i >= 0:
                carry += ord(num1[i]) - ord('0') #重要转化成ord
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
            result += chr(carry % 10 + ord('0')) #ord(num1[i]) - ord('0')
            carry //= 10
            i -= 1
            j -= 1
        if carry == 1:
            result += '1'
        return result[::-1]
```



### 是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前

### 是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前是

```python
    i = len(num1) - 1
    j = len(num2) - 1
```

### 之前

### **306累加数+842将数组拆分成斐波那契数列**

```python
#双重循环sub1，sub2 ,
# 注意0开头，长度限制
#startswith 递归
#842
1要输出数组结果的话dfs(字符，路径，结果)
满足时结果添加路径self.dfs(num_str[i+1:], path + [int(curr)], res) 递归
class Solution:
    def splitIntoFibonacci(self, S: str) -> List[int]:
        res = []
        self.dfs(S, [], res)
        return res
        
    def dfs(self, num_str, path, res): #dfs(字符，路径，结果)
        if len(path) >= 3 and  path[-1] != path[-2] + path[-3]:#三个不满足
            return False
        if not num_str and len(path) >= 3: #满足条件
            res.extend(path)
            return True
        for i in range(len(num_str)): #不断循环取出数字
            curr = num_str[:i+1]
            if (curr[0] == '0' and len(curr) != 1) or int(curr) >= 2**31: #031不行
                continue
            if self.dfs(num_str[i+1:], path + [int(curr)], res):#多重循环
                return True
        return False

```



### 0127字符排列剑指 和leetcode46类似

要做字符串的全排列。做法是把对字符串中的每个元素都当做起始位置，把其他元素当做以后的位置，然后再同样的进行操作。这样就会得到全排列

```python
#排序方法，递归
# #a,b,c分别各自，a去掉还有bc再随机选择添加，就是一个个排列
def Permutation(self, ss):
    if not ss:
        return []
    res = []
    self.dfs(ss, res, '')
    return sorted(list(set(res)))

def dfs(self, ss, res, path):
    if not ss:
        res.append(path)
    else:
        for i in range(len(ss)):
            self.dfs(ss[:i] + ss[i+1:], res, path + ss[i])
#python自带的permutations函数，直接进行全排列。
permutations(nums)
```



### 1单词个数

return len(s) - s.count("")#去掉空格

### 13. 罗马数字转整数

特殊情况出现的时候，后一位数字比前一位数字大，而正常情况正好是相反的（后一位数字一定比前一位小），后一位减去前一位即可得到这两位得到的数值，但是要注意一点，我们在这之前已经将前一位进行加和了一次，所以这时候，我们要减去 2 次前一位数字。

```python
        lookup = {
            'M': 1000,
            'D': 500,
            'C': 100,
            'L': 50,
            'X': 10,
            'V': 5,
            'I': 1
        }
        res = 0
        for i in range(len(s)):
            if i > 0 and lookup[s[i]] > lookup[s[i-1]]:#后面的更大
                res = res + lookup[s[i]] - 2 * lookup[s[i-1]]
            else:
                res += lookup[s[i]]
        return res
```

### 12整数转罗马构建字典对应

```python
#1
        for symbol, val in sorted(lookup.items(), key = lambda t: t[1], reverse = True):
        	while num >= val:
        		romanStr += symbol#减去最大的
        		num -= val
        return romanStr
    #2
    M = ['', 'M', 'MM', 'MMM']  #
     result = M[num // 1000] + C[(num % 1000) // 100] + X[(num % 100) // 10] + I[num % 10]
```

### 难度中等

#### 1、Z字形变换

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        #copy规律除以多少难
        if numRows == 1 or numRows >= len(s):
            return s
        res = [''] * numRows##多个字符串数组
        idx, step = 0, 1 #idx行数+1或者-1
    
        for x in s:
            res[idx] += x
            if idx == 0:  ## 第一行，一直向下走
                step = 1
            elif idx == numRows - 1: ## 最后一行了，向上走
                step = -1
            idx += step
        return ''.join(res) #['agm', 'bfhln', 'ceik', 'dj']

```

### 413字符串相加-简单

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        res, m, n = 0, len(num1), len(num2)
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                res += int(num1[-i]) * int(num2[-j]) * 10 ** (i + j - 2)
        return str(res)
#         m位的数字乘以n位的数字的结果最大为m+n位：只用字符串不用加减
# 99999 < 1000100 = 100000，最多为3+2 = 5位数。
# 先将字符串逆序便于从最低位开始计算。
        lookup = {"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9} # 节省查找时间，避免无休止使用ord函数来得到数字
        if num1 == '0' or num2 == '0':
            return '0'
        num1, num2 = num1[::-1], num2[::-1]
        
        tmp_res = [0 for i in range(len(num1)+len(num2))]
        for i in range(len(num1)):
            for j in range(len(num2)):
                tmp_res[i+j] += lookup[num1[i]] * lookup[num2[j]] #重点i+j）*100 

        res = [0 for i in range(len(num1)+len(num2))]
        for i in range(len(num1)+len(num2)):
            res[i] = tmp_res[i] % 10 #res保留当前位
            if i < len(num1)+len(num2)-1:
                tmp_res[i+1] += tmp_res[i]/10 #上升一位
        return ''.join(str(i) for i in res[::-1]).lstrip('0')  # 去掉最终结果头部可能存在的‘0’，反过来
```

### 43. 字符串相乘

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        res, m, n = 0, len(num1), len(num2)
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                res += int(num1[-i]) * int(num2[-j]) * 10 ** (i + j - 2)
        return str(res)
#         m位的数字乘以n位的数字的结果最大为m+n位：只用字符串不用加减
# 99999 < 1000100 = 100000，最多为3+2 = 5位数。
# 先将字符串逆序便于从最低位开始计算。
        # lookup = {"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9} # 节省查找时间，避免无休止使用ord函数来得到数字
        # if num1 == '0' or num2 == '0':
        #     return '0'
        # num1, num2 = num1[::-1], num2[::-1]
        
        # tmp_res = [0 for i in range(len(num1)+len(num2))]
        # for i in range(len(num1)):
        #     for j in range(len(num2)):
        #         tmp_res[i+j] += lookup[num1[i]] * lookup[num2[j]] #重点i+j）*100 

        # res = [0 for i in range(len(num1)+len(num2))]
        # for i in range(len(num1)+len(num2)):
        #     res[i] = tmp_res[i] % 10 #res保留当前位
        #     if i < len(num1)+len(num2)-1:
        #         tmp_res[i+1] += tmp_res[i]/10 #上升一位
        # return ''.join(str(i) for i in res[::-1]).lstrip('0')  # 去掉最终结果头部可能存在的‘0’，反过来
```

### 71. 简化路径

```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        #copy
        stack = list()
        path = [p for p in path.split('/') if p]
        for f in path:
            if f == '.': 
                continue#不管
            elif f == '..': 
                if stack: 
                    stack.pop()
            else: 
                stack.append(f)##要经常添加删除的用栈

        return '/'+'/'.join(stack)
```

## 1.11递归

### 技巧

```
        f = [1, 2, 4]
        if n <= 3: return f[n-1] #可以不用一个个写
```



### 剑指offer

```python
  # -*- coding:utf-8 -*-
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        
        x0 = y0 = 0
        xn = len(matrix)-1
        yn = len(matrix[0])-1
        list = []
        while x0<=xn and y0<=yn:
            for y in range(y0, yn+1):
                list.append(matrix[x0][y])
            for x in range(x0+1, xn+1):
                list.append(matrix[x][yn])
            if x0 < xn:
                for y in range(yn-1, y0-1, -1):
                    list.append(matrix[xn][y])
            if y0 < yn:
                for x in range(xn-1, x0, -1):
                    list.append(matrix[x][y0])
            x0 += 1
            y0 += 1
            xn -= 1
            yn -= 1
        return list
```



#### 合成链表

```python
#输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

#mergepHead发给到一个链表中,下一个递归
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if pHead1 == None:
            return pHead2
        elif pHead2 == None:
            return pHead1

        mergepHead = None
        if pHead1.val <= pHead2.val:
            mergepHead = pHead1
            mergepHead.next = self.Merge(pHead1.next, pHead2)
        else:
            mergepHead = pHead2
            mergepHead.next = self.Merge(pHead1, pHead2.next)

        return mergepHead
```

#### 剑指offer2

```python
# -*- coding:utf-8 -*-
class Solution:
    def rectCover(self, number):
        # write code here
        #循环
        if number <= 0:
            return 0
        list = [1,2]
        while number>=2:
            list[0],list[1] = list[1], list[0]+list[1]
            number -= 1
        return list[0]
        


#递归
        '''
        if number<=0:return 0
        elif number<=2:return number

        else:
            return self.rectCover(number-1)+ self.rectCover(number-2)
            '''
```

PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

递归重复操作

- 回文- 阶乘 factorial， 慕指数- 分形- Tower of Hanoi
  典型的例子：
  pow(x,n)
  isPalindrome
  TowerofHanoi
  binarySearch

三要素

 **第一要素：明确你这个函数想要干什么** 

 **第二要素：寻找递归结束条件** ：

 你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件 

 **第三要素：找出函数的等价关系式** 

 **递归结束条件是否够严谨问题** 

### 案例1：斐波那契数列

```python
int f(int n){
2    // 1.先写递归结束条件
3    if(n <= 2){
4        return n;
5    }
6    // 2.接着写等价关系式
7    return f(n-1) + f(n - 2);
8}
```

### 案例2：小青蛙跳台阶

### 案例3：反转单链表。

```java
 1//用递归的方法反转链表
 2public static Node reverseList2(Node head){
 3    // 1.递归结束条件
 4    if (head == null || head.next == null) {
 5             return head;
 6         }
 7         // 递归反转 子链表
 8         Node newList = reverseList2(head.next);
 9         // 改变 1，2节点的指向。
10         // 通过 head.next获取节点2
11         Node t1  = head.next;
12         // 让 2 的 next 指向 2
13         t1.next = head;
14         // 1 的 next 指向 null.
15        head.next = null;
16        // 把调整之后的链表返回。
17        return newList;
18    }
```



### 687. 最长同值路径

```python
class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        self.res = 0
        def dir_length(node):
            if not node:
                return 0
            left_len = dir_length(node.left)     # 左节点的length
            right_len = dir_length(node.right)   # 右节点的length
            left_dir, right_dir = 0, 0
            if node.left and node.left.val == node.val:
                left_dir = left_len + 1          # 当前节点的左节点方向的length
            if node.right and node.right.val == node.val:
                right_dir = right_len + 1        # 当前节点的右边节点方向的length
            self.res = max(self.res, left_dir + right_dir) #self.res
            return max(left_dir, right_dir) #返回更大的
        dir_length(root)
        return self.res
```



```python
        if not s:
            return 0

        return self._numDecodings(s)
        
    def _numDecodings(self, nums):
        if not nums: #递归的过程中，递归到了s的末尾了，此时应该返回1，2+0是一种情况
            return 1

        result = 0
        if 1 <= int(nums[0]) <= 9:
            result += self._numDecodings(nums[1:])#单个后面继续
        
        if len(nums) >= 2 and 10 <= int(nums[0:2]) <= 26:#两个后面继续
            result += self._numDecodings(nums[2:])
```

### 669. 修剪二叉搜索树

```python

class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        #copy想太久：
        if not root:
            return None
        if root.val >R:
            return self.trimBST(root.left, L, R)
        elif root.val <L:
            return self.trimBST(root.right, L, R)
        else:
            root.left = self.trimBST(root.left, L, R) #递归
            root.right = self.trimBST(root.right, L, R)
```



## 1.12动态规划

会想到问题：

前后关联先考虑dp

字符串匹配问题，和前面状态有关系的问题，m，n 在-1前和现在有关系的问题

### 概念

DP题一般都会满足三个条件：***\*子问题重叠\****、***\*无后效性\****、***\*最优子结构性质\****。

动态规划把原问题看作若干个重叠子问题，每个子问题的求解过程都是一个阶段，

动态规划要求当前阶段不会被后续阶段影响（即已经解决的子问题不被后续子问题影响），这便是无后效性。

一般情况下，动态规划在解决最优问题时，每个阶段的最优解应该由前面阶段的最优解导出，这便是最优子结构性质。

解决动态规划问题，重点在于***\*状态\****与***\*状态转移方程\****：



动态规划大致的思路就是：

　　把一个庞大的问题每次只完成一小步，每次都得到一个阶段的结果，然后用这个结果去当作下一阶段的开始状态。

　　并且每一步都是一个决策，不会影响接下来阶段的决策，每个阶段是独立的。

### **背包问题：**：组合的最小最大问题

 **常见的背包问题有1、组合问题。2、True、False问题。3、最大最小问题。**

 https://www.cnblogs.com/anzhengyu/p/11408466.html 

 https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/ 

如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。

```python
这个问题基本思路很简单，一个物体选择放或者不放。这个时候我们就可以假设一个最终状态f[i][v] （ 自顶向下考虑，自底向上实现 ） 表示为前 i 个物体恰好放到背包中的最大价值。由此可以得到转台转移方程

f[i][v] = max(f[i-1][v],f[i-1][v-c[i]]+w[i])
```

#### 01背包

 0-1 背包问题：给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。 

背包问题技巧：

```python

组合问题公式
dp[i] += dp[i-num]
True、False问题公式
dp[i] = dp[i] or dp[i-num]
最大最小问题公式
dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)

#1.如果是0-1背包，数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；

for num in nums:
    for i in range(target, nums-1, -1):
#2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。
for num in nums:
    for i in range(nums, target+1):
#3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。
for i in range(1, target+1):
    for num in nums:

```

 **m[ i ] [ j ] 表示 前i个物品，且背包体积为  j 时所能获得的最大价值** 

```python
for i in range(1, n+1):
    for j in range(1,v+1):
        dp[i][j] = dp[i-1][j]  # 第i个物品不选
        if j>=goods[i-1][0]:# 判断背包容量是不是大于第i件物品的体积，可以没有前面所有
            # 在选和不选的情况中选出最大值
            dp[i][j] = max(dp[i][j], dp[i-1][j-goods[i-1][0]]+goods[i-1][1])
```

#### 完全背包

 有N件物品和一个容量为V的背包，**每件物品都有无限个！**。 第i件物品的体积是vi，价值是wi。

```python
for i in range(n):
    for j in range(v+1):
        if j >= goods[i][0]:
            dp[j] = max(dp[j], dp[j-goods[i][0]] + goods[i][1])

```



#### 多重背包

### 贪心

https://cloud.tencent.com/developer/article/1092766

贪心算法只能通过解局部最优解的策略来达到全局最优解

1. 从问题的某个初始解出发。
2. 采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。
3. 将所有部分解综合起来，得到问题的最终解。

#### **实例2 活动安排问题**

 设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si <fi 。要求设计程序，使得安排的活动最多。

若被检查的活动i的开始时间starti小于最近选择的活动j的结束时间endj，则不选择活动i，否则选择活动i加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。

#### **实例3 最小生成树（克鲁斯卡尔算法）**

Kruskal算法简述 假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。

之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；

反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。

#### 实例4 hdu1050-Moving Tables

 在一个狭窄的走廊里将桌子从一个房间移动到另一个房间，走廊的宽度只能允许一个桌子通过。给出t，表示有t组测试数据。再给出n，表示要移动n个桌子。n下面有n行，每行两个数字，表示将桌子从a房间移到b房间。走廊的分布图如一图所示，每移动一个桌子到达目的地房间需要花10分钟，问移动n个桌子所需要的时间。

解题思路:

 若移动多个桌子时，所需要经过的走廊没有重合处，即可以同时移动。若有一段走廊有m个桌子都要经过，一次只能经过一个桌子，则需要m*10的时间移动桌子。 设一个数组，下标值即为房间号。桌子经过房间时，该房间号为下标对应的数组值即加10。最后找到最大的数组值，即为移动完桌子需要的最短时间

#### 剪绳子

```python
   # -*- coding:utf-8 -*-
class Solution:
    def cutRope(self, number):
        n=number
        # write code here
        if n < 2 :
            return 0
        elif n == 2:
            return 1
        # elif n == 3:
        #     return 2
        max_list = [0,1,2]
        for i in range(3,n+1):
            if i < n :
                max = i
            else:
                max = 0
            for j in range(1,i//2+1):
                tmp = max_list[j]*max_list[i-j]
                if tmp > max:
                    max = tmp
            max_list.append(max)

```



有多种情况选择

f(i)=f(i-1)+f(i-2)

##### 批量数组

 dp[1:4] = [1, 2, 3]

##### 会有循环



 **动态规划遵循一套固定的流程：递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法**。 

（ 80% 的题，都是要用二维数组的 ）

 90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。 

 不管多难找，大部分情况下，dp[i] [j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，**从规模小的，通过一些操作，推导出规模大的。 

 连续刷几十道，保证你以后再也不怕动态规划了。当然，遇到很难的，咱还是得挂。 

 80% 的题都可以通过画图一下子知道怎么优化 

 **第一步骤**：定义**数组元素的含义** 

 **第二步骤**：找出**数组元素之间的关系式** 

 **第三步骤**：找出**初始值**。

### 题目

      -  coin change
      -  longest common subsequence
      -  edit distance
      
      - Fibonacci Numbers
    - Shortest Path (no cycles)
    
    - subproblems
    - guessing
    - relate subproblems
    - recurse & memoize (bulid DP table)
    - solve original problem
    感觉DP有几类：- 容易写出递推公式的- 画表更容易理解的

### 案例一、简单的一维 DP-青蛙跳台阶

或者用字典dp = {}，一维度

### 案例二：二维数组的 DP

### 62 不同路径-机器人网格移动

一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j - 1) 这个位置走一步到达

因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。

```python
if m==1 or n==1:return 1
dp = [[1]*n for _ in range(m)]
for i in range(1,m):
    for j in range(1,n):
        dp[i][j]=dp[i-1][j]+dp[i][j-1]
return dp[m-1][n-1]
```

### 64. 最小路径和

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        #me
        m=len(grid)
        n=len(grid[0])
        dp = [[1]*n for _ in range(m)]
        dp[0][0]=grid[0][0]
        if m==1 :return sum(grid[0])
        elif n==1:
            for i in range(1,m):
                dp[i][0]=dp[i-1][0]+grid[i][0]
            return dp[m-1][n-1]

        #初始化第一行第一列
        for i in range(1,m):
            dp[i][0]=dp[i-1][0]+grid[i][0]
        for i in range(1,n):
            dp[0][i]=dp[0][i-1]+grid[0][i]
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]= min(grid[i][j]+dp[i-1][j], grid[i][j]+dp[i][j-1])
        return dp[m-1][n-1]
```

### 72. 编辑距离（hard

一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。（别忘了 dp[i] [j] 的含义哈）。

二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：

（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;

（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;

（3）、如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;

 **dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;** 

  i 或者 j 有一个为 0，是不能使用关系式，所以 计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。 

 容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了 

```java
public int minDistance(String word1, String word2) {
    int n1 = word1.length();
    int n2 = word2.length();
    int[][] dp = new int[n1 + 1][n2 + 1];
    // dp[0][0...n2]的初始值
    for (int j = 1; j <= n2; j++) 
        dp[0][j] = dp[0][j - 1] + 1;
    // dp[0...n1][0] 的初始值
    for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;
        // 通过公式推出 dp[n1][n2]
    for (int i = 1; i <= n1; i++) {
        for (int j = 1; j <= n2; j++) {
            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)){
                p[i][j] = dp[i - 1][j - 1];
            }else {
               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }         
        }
    }
    return dp[n1][n2];  
```

### 279 完全平方数-典型dp组合问题

```python
def numSquares(self, n: int) -> int: #平方和需要的最小个数
    while len(self.dp) <= n:
        m = len(self.dp)
        inf = float('inf')
        i = 1
        while i * i <= m:  # 最多m个1,长度
            inf = min(inf, self.dp[m - i * i] + 1)  # 1 + min(dp[i - 1*1], dp[i - 2*2], dp[i - 3*3])+1
            i += 1
        self.dp.append(inf)  # 1,2 ,3,4
    return self.dp[n]
```

 **完全平方数的个数最少**，我们在什么算法中用到过**最少**这个关键字？啊哈！**最短路径问题**。那 

 Lagrange 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 

满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定

满足 n= 4^a(8b + 7)

#### 典型dp





### 322 零钱兑换

```python
'''amount最少用几个硬币'''
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 此题可用动态规划求解，类似与背包问题，但每个硬币可用多次
        # dp[i] = min(dp[i-vj]+1)， vj 是硬币的面额
 # 选更小的dp[i - 1]+1, dp[i - 2]+1, dp[i - 5]) +1;;;i要用coin组合所以i>=coin
        dp = [float('inf') for i in range(amount + 1)]
        dp[0] = 0
        for i in range(amount + 1):
            for coin in coins:
                if coin <= i and dp[i - coin] + 1 < dp[i]:
                    dp[i] = dp[i - coin] + 1

        return dp[-1] if dp[-1] != float('inf') else -1  # 没变就是不能
```

### 518.零钱兑换 II

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        #copy'''给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数
        dp = [0] * (amount + 1)#0种
        dp[0] = 1
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] += dp[x - coin]  #dp[x]凑成x元的组合数每个coin都是1则为3）
        return dp[amount]
```



### 300. 最长上升子序列



### 0315-

EditDistance,求两个字符串最小编辑距离，动态规划

```
将一个字符串变成另外一个字符串所用的最少操作数，每次只能增加、删除或者替换一个字符。
```

### 42接雨水

```python
'''动态编程思路：直接按问题描述进行。对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。'''
for i in range(1,n):
    l_max[i]=max(height[i],l_max[i-1]) #数组类  0,1,12,2,2,2,3,33333
```



## 1.13 回溯（11.14

最近写算法题，经常用到回溯法和深度优先算法，总感觉它们的思路其实是差不多的。
回溯法是求问题的解，使用的是DFS（深度优先搜索）。在DFS的过程中发现不是问题的解，那么就开始回溯到上一层或者上一个节点。DFS是遍历整个搜索空间，而不管是否是问题的解。所以更觉得回溯法是DFS的一种应用，DFS更像是一种工具


回溯法  backtrack  不行就回去

```python
#17. 电话号码的字母组合
if len(digits)==0:
    return []
d={'2':'abc', '3':'def', '4':'ghi', '5':'jkl', 
         '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}
def dfs(digits,index,path,res,d):
    if index==len(digits):
        print(path)
        print("添加")
        res.append(''.join(path))
        return
    digit=digits[index]
    for c in d.get(digit,[]):
        path.append(c)
        dfs(digits,index+1,path,res,d)
        path.pop()
res=[]
dfs(digits,0,[],res,d)
return res

#46全排列
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        if len(nums) == 0:
            return []
        if len(nums) == 1:
            return [nums]
        res = []
        for i in range(len(nums)):
            prefix = nums[i]
            rest = nums[:i] + nums[i+1:]#第一个不变--第二个不变
            for j in self.permute(rest):
                res.append([prefix]+j)
        return res
```



### 1理论

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

所谓Backtracking都是这样的思路：在当前局面下，你有若干种选择。那么尝试每一种选择。如果已经发现某种选择肯定不行（因为违反了某些限定条件），就返回；如果某种选择试到最后发现是正确解，就将其加入解集

所以你思考递归题时，只要明确三点就行：选择 (Options)，限制 (Restraints)，结束条件 (Termination)-左右括号

## 1.14 分治

分别比较

```python
if not matrix:
    return False
r, c = len(matrix), len(matrix[0])
i, j = r-1, 0
while i >= 0 and j < c:
    if matrix[i][j] == target:
        return True
    elif matrix[i][j] < target:
        j += 1
    else:
        i -= 1
return False
```



## 1.15二分

### 1理论

容易边界出错

### 278. 第一个错误的版本

以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少调用 API 次数。

```python
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        #me:二分查找？要找连续的两个，一个个对比次数太多--难点：边界问题
        # left,right=0,n  #要从0开始，万一只有一个数字
        # while left<right: #错误
        #     m=(left+right)//2
        #     if isBadVersion(m)==True:
        #         right=m-1 #m
        #     else:
        #         left=m+1
        # return left
        l, r = 0, n - 1
        while l <= r:
            mid = (l + r) //2
            if not isBadVersion(mid):
                l = mid + 1
            else:
                r = mid - 1
        return l
        #copy
        # l, r = 0, n #会一直移到l和r响铃
        # while l < r:
        #     mid = (l + r) >> 1
        #     if isBadVersion(mid):
        #         r = mid
        #     else:
        #         l = mid + 1
        # return l
```



```python
#递归
function Binary_Search(x, A, l, u)
	if u < l then 
		No found error
	else
		m ← l + [ ( u - l ) / 2 ] 	 //避免溢出
		if A[m] = x then
			return m
		if x < A[m] then
			return Binary-Search(x, A, l, m - 1)
		else
			return Binary-Search(x, A, m + 1, u)
#2迭代
def binarySearch(nums, target):
    l, r = 0, len(nums) -1
    while l <= r: #注意<=
        mid = (l+r) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] > target:
            r = mid - 1
        else:
            l = mid + 1
    return -1
```

## 1.16排序

### 堆排序

![1584885992081](C:\Users\sereny\AppData\Roaming\Typora\typora-user-images\1584885992081.png)

 https://www.cnblogs.com/chengxiao/p/6129630.html 

### ***\*1字母异位：先排序\****[字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

#### ***\*#字母统计\****

 \#s.count('a') ,

### ***\*2\****[按奇偶排序数组 II](https://leetcode-cn.com/problems/sort-array-by-parity-ii/)***\*--先把奇偶分开\****

2先定义数组。隔两个赋值

 result = [0]*A_len

​    for a in A:

​      if a&1 == 0:

​        result[i] = a #先定义数组。隔两个赋值

​        i += 2

## 1.17位运算



### 运算符+常用代码

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位**与**运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位**或**运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位**异或**运算符：当两对应的二进位相异时，结果为1          | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位**取反**运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**~x** 类似于 **-x-1** | (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由 **<<** 右边的数字指定了移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，**>>** 右边的数字指定了移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

```python
#0
n&(n-1) #作用：将n的二进制表示中的最低位为1的改为0，不断循环用于计算1个数
也可以判断一个数是不是2得整数次幂（只有一个1） n&(n-1)=0
n & 0xffffffff #获得负数的补码，当有负数时候
n& 1 == 1:#奇数  n& 0x1也可以：只有1奇数结果为1
n& 1 == 1 #偶数
# https://blog.csdn.net/navyifanr/article/details/19496459
n << 1; #乘以2，左移1位
n << m; #乘以2的m次  n << (m-1); #乘以2的m次 //2的m次方
n >> 1 #除以2，移
n << m; #除以2的m次
(n & 1) == 1; #判断奇数
a^b=b^a #异或操作满足交换律
(x ^ y) >= 0; # true 表示 x和y有相同的符号， false表示x，y有相反的符号。
bin(2) #转化成二进制的字符串
int('1001',2)  int('ab34',16)
int(x,[base]): #base代表着参照的进制，base>=2,（base也可取0，此时和base取10一样），转化回十进制
#1不用临时变量交换两个数（面试常考：理解：https://blog.yangx.site/2016/07/06/bit-operation-skills/
a ^= b;
b ^= a;
a ^= b;
a=a+b;
b=a-b;
a=a-b;
#2变换符号 取反+1
~n + 1 
#3求绝对值
def my_abs(n)
  i = n >> 31 #取符号位 i=1负数要变换 =0不用变
  return i == 0 ? n : (~n + 1)
end
或者
(n ^ (n >> 31)) - (n >> 31);
'''
/* n>>31 取得n的符号，若n为正数，n>>31等于0，若n为负数，n>>31等于-1
若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算，
结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */'''

b & ((a-b) >> 31) | a & (~(a-b) >> 31);#取两个数最大值
a & ((a-b) >> 31) | b & (~(a-b) >> 31);#取两个数最小值
#4int最大
 (1 << 31) - 1;*//2147483647， #由于优先级关系，括号不可省略*  
  ~(1 << 31);*//2147483647* 
# 5的幂
（x-1）&x =0  
return (n > 0 and not (n & n-1))  #return 1  判断一个数是不是2的幂
#6、对某个特定位操作
#从低位到高位,取n的第m位
(n >> (m-1)) & 1；  
#从低位到高位.将n的第m位置1
n | (1 << (m-1));   /*将1左移m-1位找到第m位，得到000...1...000 n在和这个数做或运算*/ 
#从低位到高位,将n的第m位置0
n & ~(1 << (m-1));  /* 将1左移m-1位找到第m位，取反后变成111...0...1111 n再和这个数做与运算*/ 
#https://blog.csdn.net/zmazon/article/details/8262185
```

 - ***0xFFFFFFFF是*一个负数的补码。  四个字节32 bits全是1, 符号位是1，所以这个数是负数。** 
ord：对应的十进制
- 1的原码则为1000 0001，其中第一个红色数字1，表示负号 ，补码 1111 1111 
-  正数的补码和原码相同，负数的补码为除了第一位符号位之外，其他位0变1,1变0，并且最后再加1； 
- 一个整数与自己异或的结果是0
- 一个整数与0异或的结果是自己
- 

```
#负数
反码是在其原码的基础上, 符号位不变，其余各个位取反.
补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
原码是补码取反+1
```



### 2的幂  x - 1和x =0

```python
# positive x is a power of two ⇔ (x & (x − 1)) is equal to zero.
return n & (n-1) == 0 if n != 0 else False #特殊
return (n & (n-1) == 0) and (n>0)
    def powerOf2(self, n):
        if n&(n-1) == 0:
            return True
        else:
            return False
```

### 求只出现一次的数字

```
0异或它自己=它自己。如果数组中只有一个数字出现过一次，其余数字都出现了两次；
# 这样的话如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，
```

 对所有数字进行异或操作后剩下的就是那个只出现一次的数字 ：循环 res ^= num 



### 数字转为十六进制

​      num = int(''.join([str(1 - int(i)) for i in list(bin(-num)[2:].zfill(32))]), base=2)+1#-1转化成整数4294967296

```python
# 构造十进制与十六进制的转换字典
dec2hex = {**{i: str(i) for i in range(0, 10)}, **{i: chr(87+i) for i in range(10, 16)}}    

num = int(''.join([str(1 - int(i)) for i in list(bin(-num)[2:].zfill(32))]), base=2)+1#转化成整数
```

### 10进制转k进制  和k进制转10进制

```python
def d2k(num, k):          # 十进制转换为 k 进制，输出为 list
    res = []
    while num:
        res.append(num%k)
        num = num // k
    return res[::-1]     # 倒序输出
def k2d(num, k):           # k 进制转化为十进制，输出为 int
    res = 0
    numstr = list(str(num))
    l = len(numstr)
    for i in range(l):
        res += int(numstr[i]) * k**(l-i-1)
    return res

```

```
    while tmp <= r:
        record = tmp
        tmp = tmp * k + (k - 1)#每一位都设置为7，只要小于r'
```



### jianzhi-二进制中1的个数

用bin或者n（n&1）

```python
class Solution:
    def NumberOf1(self, n):
        count = 0
        if n < 0:
            n = n & 0xffffffff ##获得负数的补码
        while n:
            count += 1
            n = (n-1)&n
        return count

    def NumberOf2(self, n):
        if n < 0:
            s = bin(n & 0xffffffff) #
        else:
            s = bin(n)
        return s.count('1')
```



## 1.18其他

### x1205相加等于某个数

```python
a.sort()#循环会超时吗？相加等于某个数,不会
print(a)
for i in range(len(a)-1):
    for j in range(i+1,len(a)):
        if a[i]+a[j]==k:return True
return False
#方法2
dic = {}
for i in set(res):
    dic[i] = res.count(i) #对每个数字计数
for q in dic.keys():
    dic[q] = dic[q] - 1
    if k - q in dic.keys() and dic[k-q] != 0:#k-q有这个数量1，k-q在字典中
        return True
return False
```

### 组合

```
#### 39. Combination Sum
#### 40. Combination Sum II 使用正常递归思路
#### 216. Combination Sum III重复做跳过处理
#### 377. Combination Sum IV
```

## 迭代

 迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程 

### 7.整数反转

```
是
```



## 2shell



## 3sql

```sql
order by rating desc 
group by class having count(DISTINCT student) >= 5;
--更新
update salary set a=b
--case when 
SET sex = (CASE WHEN sex = 'm' THEN 'f' ELSE 'm' END)
```



### 多个表连接查询问题

在查询数据库表条目的时候，有时候需要从多张表中汇总信息，这个时候就需要使用到SQL的JOIN语句。JOIN是对表做连接操作，有LEFT JOIN，RIGHT JOIN和INNER JOIN等。左右连接的差别只是在ON条件表达式中不满足的时候，保留左表还是右表的数据而已
————————————————
版权声明：本文为CSDN博主「pp菌」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_36600799/article/details/89528181

### 顺序问题

数据库表查询，很多时候需要获取那一列排第几的行，这个时候可以利用SQL的LIMIT，OFFSET以及ORDER BY语句。

 需要获取第二高的元素，这个时候结合DESC降序排列即可： 

```sql
--196删除重复电子邮箱 copy复制两个表，1重复 2id大的
delete 
    p1 
from 
    Person p1,
    Person p2 
where 
    (p1.email = p2.email) and (p1.id > p2.id)#所有id大的都删掉
```

# 0302剑指offer整理

看完做类似题目，不抓紧先复习算法基础

再把书看一遍

### 类别

```
牛客67题

26：3数组+4字符串+3链表+8树+2栈队列+1查找+4递归+1位运算
21：完整代码2+鲁棒4+思路1+画图抽象1+举例抽象5+分解复杂问题3+时间效率5
20：时间空间效率4+知识迁移8+抽象建模2+发散思维2+综合1+回溯2+动态1  -22.30
知识+时间效率10题还剩+刷题
```



### 其他

```python
isinstance(target, (int, float)) 进行判断
累积乘：减少运算
#字符
s.split(' ')
'%20'.join(s)
str.replace(' ', '%20')
re.sub(r" ","%20",s) #正则
      
```

### 简单题目

```python
1数组中重复的数字:用字典
2替换空格：c++用利用双指针方法 1计算空格的数量 2指针分别指向新旧字符串的末尾
2字符流中第一个不重复的字符（字典 （一个字典一个list
3从尾到头打印链表:头插入l.insert(0, head.val) 或者翻转
4滑动窗口的最大值 :res.append(max(num[i:i+size])) 或者stack获取最大
5旋转数组的最小数字：找规律，再前面或者后面的数组，否则暴力
6斐波那契数列：递归+字典存储
7数组的整数次方：pow 书上：
8调整数组顺序使奇数位于偶数前面.两个数组耗费空间 2两个指针while到了换
9反转链表 #利用prev
10包含min函数的栈：一个栈，一个最小栈
11栈的压入、弹出序列 #举例画图让抽象具体化，找规律
12 从上往下打印二叉树：BFS
13二叉搜索树与双向链表  ：先遍历再建立链表
14第一个只出现一次的字符
15求1+2+3+...+n
16二叉树的深度：递归 return max(left, right) + 1
17判断平衡二叉树：深度的基础上（中等难度（再做
18左旋转字符串

```

链表：多用指针，字典

###  二维数组中的查找 

```python
'''在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

二维列表中找是否有target整数，行递增，列递增（行最后一个不一定小于第二行）'''
特殊：空数组
方法：两个指针，行列，先比较每行第一个数
主要代码：
row = rows - 1 #起始点重要
col = 0
while row >= 0 and col < cols: 
    if array[row][col] < target:#只可能往右，上边的都小
        col = col + 1
    elif array[row][col] > target: #右边都大，只可能往上
        row = row - 1
    else:
        return True
```

###  数字在排序数组中出现的次数 -1

1 利用快排的思想，也可以说是二分，如果在数组中找到k，那么左右拓展边界就可以确定，该数在数组中出现的次数了。 

排序递归可以字典

扩展： **给定一个数组，返回出现次数第二多的** 

```python
#快排
class Solution:
    def GetNumberOfK(self, data, k):
        if len(data) < 1: return 0
        mid = len(data)//2
        if data[mid] == k:
            start,end = mid, mid
            for i in range(mid,-1,-1):
                if data[i] == k:
                    start -= 1
            for j in range(mid+1,len(data)):
                if data[j] == k:
                    end += 1
            return end - start
        elif data[mid]>k:
            return self.GetNumberOfK(data[:mid], k)
        else:
            return self.GetNumberOfK(data[mid+1:],k)

```



### 数组中出现次数超过一半的数字 

快排-z排序查找，字典更快

```python
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        if not numbers: return 0
        res = numbers[0]
        times = 1
        length = len(numbers)
        for i in range(1, length):
            if times == 0:
                res = numbers[i]
                times = 1
            elif res == numbers[i]: 
                times += 1
            else:
                times -= 1

        import collections
        return res if collections.Counter(numbers)[res] * 2 > length else 0
#2
#个数
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        numbers.sort()
        theone = numbers[len(numbers)/2]
        if numbers.count(theone) > len(numbers)/2:
            return theone
        return  0
```



###  构建乘积数组 （连续乘）

```python
'''给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）'''
#1
for i in range(len(A)):
    B.append(submultiply(A[:i])*submultiply(A[i+1:]))
#2#累积乘：减少运算 aList[1]=1*A[0]  aList[2]=1*A[0]*A[1]
#2上下三角连乘法
class Solution:
    def multiply(self, A):
        if A == None or len(A) <= 0:#特殊
            return
        length = len(A)
        aList = [1] * length
        for i in range(1, length):# 计算上三角连乘
            aList[i] = aList[i-1] * A[i-1]#累积乘：减少运算 aList[1]=1*A[0]  aList[2]=1*A[0]*A[1]
        temp = 1
        for i in range(length-2, -1, -1): # 计算下三角连乘
            temp = temp * A[i+1]
            aList[i] *= temp 
        return aList
#3其他把A[i]变成1
```

###  连续子数组的最大和 -好

```python
'''当前的最大值以及总的最大值。当累加的子数组和小于0的时候，放弃前面的子数组。
一旦小于0，重新开始，，大于0加上前面的会更大，小于0加上只会更小'''
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if not array: return 0
        nCurSum = 0
        nGreatestSum = array[0]
        for i in range(len(array)):
            if nCurSum <= 0: nCurSum = array[i]
            else: nCurSum += array[i]
            if nCurSum > nGreatestSum: nGreatestSum = nCurSum
        return nGreatestSums
    
    # 动态规划解决问题
    def FindGreatestSumOfSubArray(self, array):
        if not array: return 0
        aList = [0]*len(array)
        for i in range(len(array)):
            if i == 0 or aList[i-1] <= 0:
                aList[i] = array[i]
            else:
                aList[i] = aList[i-1] + array[i]
        return max(aList)
```



###  正则表达式匹配

```python
'''
请实现一个函数用来匹配包括'.'和'*'的正则表达式。
'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。
'''
1回溯，考虑pattern第二个字符（*可以匹配多次）

当模式中的第二个字符不是“*”时：
1、如果第一个字符相匹配，那么都后移一个字符匹配剩余的。2、第一个字符相不匹配，直接返回false。
而当模式中的第二个字符是“*”时：
如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。(模式前面0次)
如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：
1、模式后移2字符，相当于x*被忽略；
2、字符串后移1字符，模式后移2字符；#(s[1:],pattern)匹配一个
3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；
def match(self, s, pattern):
    if s == pattern:
        return True
    if not pattern:
        return False
    if len(pattern)>1 and pattern[1] == '*':#第二个字符是*，可以匹配多次
        if(s and s[0]==pattern[0]) or (s and pattern[0] == '.'):
            return self.match(s,pattern[2:])  or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern)  
        else:  
            return self.match(s,pattern[2:]) #(模式*前面0次)
    elif s and (s[0] == pattern[0] or pattern[0]=='.'):  #第二个字符不是*：第一个必须匹配.或者相同，然后下一个继续
            return self.match(s[1:],pattern[1:])
    return False

```

### 判断字符串是否表示数值

```python
 #正常思路书上
1如果没出现'e'或者'E'就是数字，否则e前后都是数字，后面不能没值或者有
2判断数字在数字.+-e范围， 如果出现'.'，有小数部分，计数小于等于1
def scanDigit(self, alist):
    dotNum = 0
    allowVal = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '.', 'e']
    for i in range(len(alist)):
        if alist[i] not in allowVal:return False
        if alist[i] == '.': dotNum += 1 #小数点不能两个
             #+-必须在前面
        if alist[i] in '+-' and i != 0: return False
    if dotNum > 1:return False
    return True
    
    # Python trick
class Solution:
    def isNumeric(self, s):
        try:
            float(s)
            return True
        except:
            return False
```

###  字符串的排列 (循环递归)

#循环+递归，定义能够递归范围

```python
class Solution:
    def Permutation(self, ss):
        res=[]
        if len(ss)<=1:return ss
        for i in range(len(ss)):
            for j in map(lambda:x:ss[i]+x,self.Permutation(ss[:i]+ss[i+1:])):
                if j not in list:
                    res.append(j)
        return res
#2
class Solution:
    def Permutation(self, ss):
        if not ss: return []
        res = []
        self.helper(ss, res, '')
        return sorted(list(set(res)))

    def helper(self, ss, res, path):
        if not ss: res.append(path)
        else:
            for i in range(len(ss)):
                self.helper(ss[:i] + ss[i+1:], res, path + ss[i]) #取出一个，剩下的继续排列 
```



###  链表中环的入口结点 （链表，环）

1快慢指针

2字典

```python
class Solution:
    def EntryNodeOfLoop(self, pHead):
        if pHead == None or pHead.next == None:
            return None
        oneStep = pHead
        twoStep = pHead
        while oneStep and twoStep.next:
            oneStep = oneStep.next
            twoStep = twoStep.next.next
            if oneStep == twoStep:
                twoStep = pHead
                while oneStep != twoStep:
                    oneStep = oneStep.next
                    twoStep = twoStep.next
                return oneStep
        return None
    '''1. 分别用oneStep，twoStep指向链表头部，oneStep每次走一步，twoStep每次走二步， 直到oneStep==twoStep找到二者在环中的相汇点。
2. 当oneStep==twoStep时，twoStep所经过节点数为2x,oneStep所经过节点数为x,设闭环中有n个节点,
twoStep比oneStep多走k圈有2x=kn+x; nk=x;简单起见，可以看作k=1，oneStep实际走了一个环的步数，
再让twoStep指向链表头部，oneStep位置不变，oneStep,twoStep每次走一步直到oneStep==twoStep; 此时oneStep指向环的入口。
 2(A+B) = A+B+C+B.（A开始到节点B相遇 C相遇到节点）
 A=C
'''
```

###  删除链表中重复的结点 

```python
'''三个指针：当前结点前的最晚访问过的不重复结点pPre、当前结点pCur、指向当前结点后面的结点pNext的三个指针，需要考虑第一个结点是重复结点'''

def deleteDuplication(self, pHead):
    pPre = None
    pCur = pHead
    pNext = None
    while pCur != None:
        if pCur.next != None and pCur.val == pCur.next.val:  # 开头重复措辞pcur和phead回到第二个数
            pNext = pCur.next
            while pNext.next != None and pNext.next.val == pCur.val:  #
                pNext = pNext.next
            if pCur == pHead:  # 第二次开头重复
                pHead = pNext.next  # 获取第一个没有重复的开头
            else:
                pPre.next = pNext.next
            pCur = pNext.next
        else:  # 开头不重复往下移动
            pPre = pCur
            pCur = pCur.next
    return pHead
```

### 链表中倒数第k个结点（指针）

直接用数组快 2指针法

第一个指针先往前走k-1步, 然后从第k步开始第二个指针指向头结点
然后两个指针一起遍历
当地一个指针指向尾节点的时候, 第二个指针正好指向倒数第k个结点

```python
def FindKthToTail(self, head, k):
    if head == None or k <= 0: return None

    pAHead = head
    pBehind = None

    for i in range(k-1):
        if pAHead.next != None:
            pAHead = pAHead.next
        else:
            return None
    pBehind = head
    while pAHead.next != None:
        pAHead = pAHead.next
        pBehind = pBehind.next
    return pBehind
```

###  合并两个排序的链表 (递归)

```python
def Merge(self, pHead1, pHead2):
    if pHead1 == None:return pHead2
    elif pHead2 == None: return pHead1
    mergepHead = None
    if pHead1.val <= pHead2.val:
        mergepHead = pHead1
        mergepHead.next = self.Merge(pHead1.next, pHead2)
    else:
        mergepHead = pHead2
        mergepHead.next = self.Merge(pHead1, pHead2.next)

    return mergepHead
```

###  复杂链表的复制 

```python
class Solution:
    def Clone(self, pHead):
        if not pHead:  return None
        cloneHead = RandomListNode(pHead.label)
        cloneHead.random = pHead.random
        cloneHead.next = self.Clone(pHead.next)
        return cloneHead
    #非递归先复制next再复制random在连接
```

###  两个链表的第一个公共结点 

1交换走 2到一个长度差比较

```python
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        #思维：是从后往前找第一个不公共的，所以可以用栈来做呀～～全部入栈，然后同时出栈，直到不相等为止就行。
        p1,p2=[],[]
        while pHead1:
            p1.append(pHead1)
            pHead1=pHead1.next
        while pHead2:
            p2.append(pHead2)
            pHead2=pHead2.next
        pre = None
        while p1 and p2 and p1[-1] == p2[-1]:
            pre = p1.pop()
            p2.pop()
        return pre
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        if not pHead1 or not pHead2:
            return None
        p1, p2 = pHead1, pHead2
        while p1 != p2:
            p1 = pHead2 if not p1 else p1.next
            p2 = pHead1 if not p2 else p2.next
        return p1

```



### 重建二叉树 

用index确定下表，再递归

```python
#根据前序遍历和中序遍历
i = tin.index(pre[0])
root.left = self.build(pre[1:i + 1], tin[:i]) #确定左右
root.right = self.build(pre[i + 1:], tin[i + 1:])
```



### 二叉树的下一个节点

合并写也可以，下面逻辑清楚

```python
def GetNext(self, pNode): #主函数
    if not pNode:
        return
    if not pNode.right:
        return self.getHead(pNode) #没有右树，返回上
    return self.getRightNode(pNode.right) #右树的最左边

def getHead(self, pNode):#另一个子树
    while pNode.next:
        if pNode.next.right == pNode: #根节点的右节点,回到根节点
            pNode = pNode.next #再往上一层
        elif pNode.next.left == pNode: #根节点的左节点
            return pNode.next
    return None

def getRightNode(self, pNode):#最左边
    while pNode.left:
        pNode = pNode.left
    return pNode
```



###  对称的二叉树 （递归

非递归，镜像后（根左右，根右左）再次前序遍历看是否相等

```python
def recursiveTree(self, left, right):
    if not left and not right:#不存在:对称
        return True
    if not left or not right: #一个不存在:不对称
        return False
    if left.val == right.val: #都存在,左右
        return self.recursiveTree(left.left, right.right) and self.recursiveTree(left.right, right.left) #子树全都true才true
    return False
```

###  二叉树的镜像 1

交换+递归

```python
#1递归
root.left,root.right = root.right,root.left
self.Mirror(root.left)
self.Mirror(root.right)
# 2非递归实现
def Mirror(self, root):
    if root == None: return
    stackNode = [root] 
    while len(stackNode) > 0:
        node = stackNode[-1]
        stackNode.pop() #pop出去
        if node.left != None or node.right != None: #有一个存在就交换
            node.left, node.right = node.right, node.left
        if node.left:
            stackNode.append(node.left)#放进去交换
        if node.right:
            stackNode.append(node.right)
```

### 二叉树的深度

```python
   #非递归     
 class Solution:
    def TreeDepth(self, pRoot):
        if not pRoot:
            return 0
        depth = 0
        stack, tag = [], []
        pNode = pRoot
        while pNode or stack:
            while pNode:
                stack.append(pNode)
                tag.append(0)
                pNode = pNode.left
            if tag[-1] == 1:
                depth = max(depth, len(stack))
                stack.pop()
                tag.pop()
                pNode = None
            else:
                pNode = stack[-1]
                pNode = pNode.right
                tag.pop()
                tag.append(1)
        return depth
```



### 树的子结构 

递归+考虑全面（鲁棒性）

```python
'''输入两棵二叉树A，B，判断B是不是A的子结构。空树不是任意一个树的子结构'''

def HasSubtree(self, pRoot1, pRoot2):
    if not pRoot1 or not pRoot2:  return False   
    # 子结构，是左子树的子结构，是右子树的子结构
    return self.is_subtree(pRoot1, pRoot2) or self.HasSubtree(pRoot1.left, 	 pRoot2) or self.HasSubtree(pRoot1.right, Root2)

def is_subtree(self, A, B):
    if not B:  # B为空是
        return True
    if not A or A.val != B.val:  # b不为空，A为空或者ab不相等：不是
        return False
    return self.is_subtree(A.left, B.left) and self.is_subtree(A.right, B.right)
```



###  按之字形顺序打印二叉树 （常用DFS

###  把二叉树打印成多行 

常规DFS，之子：加一个flag要不要反

```python
res = []
nodeList = [pRoot]
while nodeList:
    res_layer = []
    nextL = []
    for node in nodeList:
        res_layer.append(node.val)
        if node.left: nextL.append(node.left)
        if node.right: nextL.append(node.right)
    nodeList = nextL  # 更换nodelist
```



### 序列化二叉树（根据遍历构建

```python

    def Deserialize(self, s):
        vals = deque(val for val in s.split())
        def build():
            if vals:
                val = vals.popleft()
                if val == '#':
                    return None
                root = TreeNode(int(val))
                root.left = build()#左边建好到None为止
                root.right = build()
                return root
        return build()
```

###  二叉搜索树的后序遍历序列 

1递归2二叉树性质

```python
#判断该数组是不是某二叉搜索树的后序遍历的结果
def VerifySquenceOfBST(self, sequence):
    if not sequence:return False
    root = sequence[-1] # 获取根节点
    # 根据二叉搜索树的性质，左孩子的每个结点的值都小于根节点
    for i in range(len(sequence)): #到左边结束,左孩子的每个结点的值都小于根节点
        if sequence[i] > root:
            break
    for j in range(i, len(sequence)): # 判断是否右孩子的每个结点的值都大于根结点
        if sequence[j] < root:
            return False
    # #通过i的值证明有左右孩子递归
    left = True
    if i > 0:left = self.VerifySquenceOfBST(sequence[: i])
    right = True
    if i < len(sequence) - 1:   right = self.VerifySquenceOfBST(sequence[i: -1])
    return left and right

```

###  二叉树中和为某一值的路径 (定义函数)（难度中上

1自定义函数  2递归 3结果复杂 4pop弹出

```python
'''
输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
# 返回二维列表，内部每个列表表示找到的路径
'''
def FindPath(self, root, expectNumber):
    def FindPath2(root, path, currentNum):
        currentNum += root.val
        path.append(root) #path 和 currentNum 对应，临时变量
        flag = root.left == None and root.right == None  #flag=1叶子节点，
        if currentNum == expectNumber and flag:#是叶子节点 并且 满足条件 
            onepath = []
            for node in path:
                onepath.append(node.val)
            result.append(onepath) #每条路径加进去

        if currentNum < expectNumber:#不满足继续循环
            if root.left:
                FindPath2(root.left, path, currentNum)#加到左边递归
            if root.right:
                FindPath2(root.right, path, currentNum)
        # 拿到一个正确的路径后要弹出，回到上一次父节点继续递归
        path.pop()

    if not root: return []#不存在  
    result = []
    FindPath2(root, [], 0) #[]存放路径，开始节点
    return result
```



###  二叉搜索树的第k个结点 (遍历)

###  用两个栈实现队列 

```python
    def pop(self):
        if len(self.stack2) == 0 and len(self.stack1) == 0:
            return
        elif len(self.stack2) == 0: #倒到另一个栈
            while len(self.stack1) > 0:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
```

###  栈的压入、弹出序列 

```python
#用一个stack
class Solution:
    def IsPopOrder(self, pushV, popV):
        stack = []
        while popV:
            # 压入就弹出
            if pushV and pushV[0] == popV[0]:
                popV.pop(0)
                pushV.pop(0)
            #压到要弹出的那个数字
            elif stack and stack[-1] == popV[0]:
                stack.pop()
                popV.pop(0)
            elif pushV:  #压入
                stack.append(pushV.pop(0))
            else:
                return False
        return True
```

### 矩形覆盖 （递归不超时）

```python
class Solution:
    def rectCover(self, number):
        if number <= 0:return 0
        list = [1,2]
        while number>=2:
            list[0],list[1] = list[1], list[0]+list[1] #2.3   3.5
            number -= 1
        return list[0]
```



### 二进制中1的个数 

理解： https://www.cnblogs.com/shengguorui/p/10907382.html 

```python
    def NumberOf1(self, n):
        count = 0
        if n < 0:
            n = n & 0xffffffff ##获得负数的补码
        while n:
            count += 1
            n = (n-1)&n
        return count
    def NumberOf2(self, n):
        if n < 0:
            s = bin(n & 0xffffffff)
        else:
            s = bin(n)
        return s.count('1')
    
#判断两个数的二进制表示有多少位不一样, 直接比较两个数二进制异或就可以
    def andOr(self, m, n):
        diff = m^n
        count = 0
        while diff:
            count += 1
            diff = diff&(diff-1)
        return count
```

### 数值的整数次方

```python
result = self.Power(base, exponent >> 1) #exponent//2
result *= result
if (exponent & 0x1) == 1: #判断奇偶，==1为奇数，比%效率更高，基数乘以原本base
    result *= base
```

###  顺时针打印矩阵 :四个方向DFS等

```python
def printMatrix(self, matrix):
    x0 = y0 = 0
    xn = len(matrix) - 1
    yn = len(matrix[0]) - 1
    list = []
    while x0 <= xn and y0 <= yn:
        for y in range(y0, yn + 1):
            list.append(matrix[x0][y])
        for x in range(x0 + 1, xn + 1):
            list.append(matrix[x][yn])
        if x0 < xn:
            for y in range(yn - 1, y0 - 1, -1):
                list.append(matrix[xn][y])
        if y0 < yn:
            for x in range(xn - 1, x0, -1):
                list.append(matrix[x][y0])
        x0 += 1
        y0 += 1
        xn -= 1
        yn -= 1
    return list
```

###  矩阵中的路径 （中上

```
#四个方向，自定义函数
# 如果不能再走下一步，需要回退到上一状态
2.取一个boolean[matrix.length]标记某个字符是否已经被访问过,用一个布尔矩阵进行是否存在该数值的标记。
3.如果没找到结果，需要将对应的boolean标记值置回false,返回上一层进行其他分路的查找。
self.hasPathCore(matrix, rows, cols, row, col, path, pathlength, markmatrix):
```

###  机器人的运动范围 （（中上，再做

```
    '''思路：同上一题思路一样，判断条件改成了行坐标和列坐标的数位之和大于k'''
```



###  整数中1出现的次数

```python
找规律'''从 1 至 10，在它们的个位数中，数字1出现了 1 次。
从 1 至 100，在它们的十位数中，数字1出现了 10 次。
从 1 至 1000，在它们的百位数中，数字1出现了 100 次。依此类推，从 1 至 10i，在它们右数第二位中，数字1出现了10 ^ (i - 1)次。

总结一下以上的步骤，可以得到这么一个规律：
对于数字n，计算它的第i(i从1开始，从右边开始计数)位数上包含的数字1的个数：
假设第i位上的数字为x的话，则
1.如果x > 1的话，则第i位数上包含的1的数目为：(高位数字 + 1）* 10 ^ (i-1)  (其中高位数字是从i+1位一直到最高位数构成的数字)
2.如果x < 1的话，则第i位数上包含的1的数目为：(高位数字 ）* 10 ^ (i-1)
3.如果x == 1的话，则第i位数上包含1的数目为：(高位数字) * 10 ^ (i-1) +(低位数字+1)   (其中低位数字时从第i - 1位数一直到第1位数构成的数字)'''
    def NumberOf1Between1AndN_Solution(self, n):
        ones, m = 0, 1
        while m <= n:
            ones += (n // m + 8) // 10 * m + (n // m % 10 == 1) * (n % m + 1)
            m *= 10
        return ones
```

###  把数组排成最小的数 (再做)

```python
from functools import cmp_to_key
# -*- coding:utf-8 -*-
class Solution:
    def PrintMinNumber(self, numbers):
        if numbers == None or len(numbers) <= 0:return ''
        strList = []
        for i in numbers:
            strList.append(str(i))
        key = cmp_to_key(lambda x, y: int(x+y)-int(y+x))  # key是一种比较规则，比较 x+y 和 x-y 的大小, 因为为str型, 需要先转换成int型
        strList.sort(key=key)
        return ''.join(strList)
    # 使用冒泡排序
    def PrintMinNumber2(self, numbers):
        if numbers == None or len(numbers) <= 0:
            return ''
        strNum = [str(m) for m in numbers]
        for i in range(len(numbers)-1):
            for j in range(i+1, len(numbers)):
                if strNum[i] + strNum[j] > strNum[j] + strNum[i]:
                    strNum[i], strNum[j] = strNum[j], strNum[i]
        return ''.join(strNum)
        
        
class Solution:
    def PrintMinNumber(self, numbers):
        if numbers is None or len(numbers) == 0: return ""
        numbers = map(str, numbers)  #映射为字符串数组
        numbers.sort(cmp = lambda x, y : cmp(x + y, y + x))
        return "".join(numbers).lstrip()
```

### 丑数

利用指针

```python
class Solution:
    def GetUglyNumber_Solution(self, index):
        if index < 1: return 0
        res = [1]
        t2 = t3 = t5 = 0
        nextNum = 1
        while nextNum < index:
            minNum = min(res[t2] * 2, res[t3] * 3, res[t5] * 5) #2,3,5    2把最小的依次放进去
            res.append(minNum)
            if res[t2] * 2 <= minNum:
                t2 += 1
            if res[t3] * 3 <= minNum:
                t3 += 1
            if res[t5] * 5 <= minNum:
                t5 += 1
            nextNum += 1
        return res[nextNum - 1]

```

### 剪绳子

   动态规划与贪婪 ：剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 

```python
class Solution:
    def cutRope(self, number):
        length=number
        if length==2:return 1 
        if length==3: return 2          
        li=[0,1,2,3]
        for j in range(4,length+1):
            max = 0
            for i in range(1,j):
                temp=li[i]*li[j-i]#f（4）=f（2）*f（2），f（1）*f（3）递归求解也能解出，但会造成大量重复执行
                if temp>max: max=temp
            li.append(max)#每次将上次所得最优追加在列表里
        return li[-1] 
```

###  孩子们的游戏(圆圈中最后剩下的数) (找规律抽象建模)

```python
class Solution:
    def LastRemaining_Solution(self, n, m):
        if n < 1 or m < 1:  return -1
        last = 0
        for i in range(2, n + 1):
            last = (last + m) % i
        return last

```

###  扑克牌顺子 （规律逻辑

```python
'''
大\小 王数组中是0可以看成任何数字,并且A看作1,J为11,Q为12,K为13。
 现在,如果牌能组成顺子就输出true，否则就输出false。'''
# 不能存在对子，必须5个，0可以替代其他值
class Solution:
    def IsContinuous(self, numbers):
        if len(numbers) < 5: return False
        
        nOfZero = numbers.count(0)  # 计算0的个数
        numbers.sort()  # 排序
        sumOfGap = 0  # 计算空缺个数
        # 遍历非0部分的递增序列
        for i in range(nOfZero, len(numbers) - 1):
            small = numbers[i]
            big = numbers[i + 1]
            if small == big:  # 当前与下一个值的比较，若相等则说明存在对子
                return False
            else:  # 则得到二者的差再减1，计算空缺个数
                sumOfGap += (big - small - 1)
        if nOfZero >= sumOfGap:  # 判断0的个数大于等于间隔值，则说明满足连续条件
            return True
        else:
            return False
```

### 不用加减乘除做加法 （位运算，再做

```python
class Solution:
    def Add(self, num1, num2):
        while num2 != 0:
            temp = num1 ^ num2
            num2 = (num1 & num2) << 1
            num1 = temp & 0xFFFFFFFF
        return num1 if num1 >> 31 == 0 else num1 - 4294967296


class Solution:
    def Add(self, num1, num2):
        while num2:
            sum1 = num1 ^ num2
            carry = 0xFFFFFFFF & ((num1 & num2) << 1)# 0xffffffff表示的是一个十六进制数1.
            if carry > 0x7FFFFFFF:
                carry = -(~(carry - 1) & 0xFFFFFFFF)
            num1 = sum1
            num2 = carry
        return num1
```

###  求1+2+3+...+n 

```python
'''求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。'''
class Solution:
    def Sum_Solution(self, n):
        if n==0: return 0
        out=n**2
        out+=n
        out=out>>1
        return out #（n+1）*n公式变成位运算
```

###   数组中只出现一次的数字 （再看做

```python
#2位运算不太会，字典更快
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    # 这个题和260. Single Number III完全一样，都是使用异或运算。
    # 用异或求解。异或运算的性质：任何一个数字异或它自己都等于0 0异或它自己=它自己。如果数组中只有一个数字出现过一次，其余数字都出现了两次；
    # 这样的话如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，
    def FindNumsAppearOnce(self, array):
        xor = 0
        for i in array:
            xor ^= i
        num1, num2 = 0, 0
        mask = 1
        while xor & mask == 0:
            mask <<= 1
        for num in array:
            if num & mask == 0:
                num1 ^= num
            else:
                num2 ^= num
        return [num1, num2]

```

### 

```
# -*- coding:utf-8 -*-
class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        if s == pattern:
            return True

    if not pattern:
        return False
    if len(pattern) > 1 and pattern[1] == '*':
        if (s and s[0] == pattern[0]) or (s and pattern[0] == '.'):
            return self.match(s, pattern[2:]) \
                   or self.match(s[1:], pattern) \
                   or self.match(s[1:], pattern[2:])
        else:
            return self.match(s, pattern[2:])
    elif s and (s[0] == pattern[0] or pattern[0] == '.'):
        return self.match(s[1:], pattern[1:])
    return False
```

# 面试题思路

```python
记录
0317正数反转难点:溢出 # 流程 sum=sum*10+x%10： 难点：溢出问题：
    #32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。
```



```
数组各自的和的差值最小...1排序、2求出和的一半、最后一个开始比较，3更大：放到新列表、half也减去
```

###  算出abc**全排列** :

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        result = []
        def backtrack(nums, middle):
            if not nums:
                result.append(middle)
                return #重要
            
            for i in range(len(nums)): #重要
                backtrack(nums[:i] + nums[i+1:], middle + [nums[i]])
        backtrack(nums,[])
        return result
#2
def permutations(arr, position, end):
    if position == end:
        print(arr)
    else:
        for index in range(position, end):
            arr[index], arr[position] = arr[position], arr[index]
            permutations(arr, position + 1, end)
            arr[index], arr[position] = arr[position], arr[index]  # 还原到交换前的状态，为了进行下一次交换
arr = [1, 2, 3, 4]
permutations(arr, 0, len(arr))
#3去重全排列
def isswap(array,i,j):    # 定义检查函数，检查能不能交换
    if i == j:
        return True
    for n in range(i,j):
        if array[n] != array[j]:  
            continue
        else:  # 如果在这个区间内有元素与array[j]相等的话，
            return False
    return True
def permutations(arr, begin, end):
    if begin == end:
        print(arr)
    else:
        for index in range(begin, end):
            if isswap(arr,begin,index): #添加这一句
                arr[index], arr[begin] = arr[begin], arr[index]
                permutations(arr, begin + 1, end)
                arr[index], arr[begin] = arr[begin], arr[index]

```

### 禁用词过滤  前缀匹配法+树的二分查找

 https://blog.csdn.net/weixin_34153893/article/details/91877172 

还可以字典法

```
遍历文本词是否在禁用词(禁用词量太大
可以对违禁词的数据结构做一定的设计，加快一个词在其中的查找，树状等
前缀匹配法:
判断此汉字是否是某个违禁词的开头，是：继续下一步；否：返回第1步。
     4.   继续读取下一个字符（若最后一个字节：跳至结束），判断是否为汉字，是：继续下一步；否：返回第一步。
     5.   将上一步得到汉字和前面的汉字组成字符串，判断是否是某个违禁词的前缀。是：继续下一步；否：跳回第1步（取w+1字节）。
     6.   查看这个前缀是否就是违禁词。是继续下一步
```

### 手写kmeans

```python

def distance(vec1,vec2):
    return np.sqrt(np.sum(np.square(vec1-vec2)))
 
def kmeans(data,k):
    # 初始化质心
    K=np.random.uniform(0,10,(k,data.shape[1]))
    print("初始化质心：{}".format(k))
    #创建一个数组用来存储聚类结果
    ret=np.zeros((data.shape[0],2))
    flag=True
    while flag:
        flag=False
        for i in range(data.shape[0]):
            print("数据的每一行：{}".format(data[i]))
            minDist=np.inf
            minIndex=-1
            print(K.shape[1])
            for j in range(K.shape[0]):
                print("第{}个质心点{}".format(j,K[j]))
                #计算数据中的每个点到聚类中心的距离
                ds=distance(data[i],K[j])
                print("距离：{}".format(ds))
                if ds<minDist:
                    minDist=ds
                    minIndex=j
                    print("距离和簇中心:{}   {}".format(ds,str(j)))
            #每次计算完一行数据到质心的距离后，更新ret矩阵的结果（将数据点分给距离其最近的簇）
            ret[i][0]=minDist
            ret[i][1]=minIndex
        print()
        #对每个簇，计算簇中所有点的均值并将均值作为质心
        for i in range(k):
            cluster=data[ret[:,1]==i]
            center = np.mean(cluster, axis=0)

            if (center == K[i]).all():
                pass
            else:
                flag=True #继续
                K[i] = center

```

```python

def distance(vec1,vec2):
    return np.sqrt(np.sum(np.square(vec1-vec2)))
 
def kmeans(data,k):
    K=np.random.uniform(0,10,(k,data.shape[1])) # 初始化质心
    ret=np.zeros((data.shape[0],2))#创建一个数组用来存储聚类结果距离和质心
    flag=True
    while flag:
        flag=False #标志下一轮是否继续，如果质心不变
        for i in range(data.shape[0]):
            minDist=np.inf
            minIndex=-1
            for j in range(k):
                ds=distance(data[i],K[j])#计算数据中的每个点到聚类中心的距离
                if ds<minDist:
                    minDist=ds
                    minIndex=j
            ret[i][0]=minDist #存储距离和质心
            ret[i][1]=minIndex
            
        for i in range(k): #对每个簇，计算簇中所有点的均值并将均值作为质心
            cluster=data[ret[:,1]==i]#或者这个质心的数据
            center = np.mean(cluster, axis=0) #均值

            if (center == K[i]).all():
                pass
            else:
                flag=True #继续
                K[i] = center#更新质心

```



# 其他好题

### 军训队列-dp递归

```python
def result(list, step):
    if len(list) <= 3:  #如果不多于3人，则应该返回结果
        return list
    res = []    #用于存储结果
    if step == 2:   #1到2报数
        res = list[::2] # 剩下1 的人存给新列表res，从第一个开始，步长为2
        return result(res, 3)   #递归调用：再对res进行1到3报数
    else:   #1到3报数
        cur = 0 #临时变量 表示当前所在0号位置 我们进行向下遍历操作
        while cur < len(list):  #如果当前还没到队尾
            res.append(list[cur])   #把当前这个人放到res里
            if cur + 1 < len(list):
                res.append(list[cur + 1])   #把这个人的下一个人也放res里
            cur += 3    #cur向后移动3人的位置
        #跳出循环后，我们把报1和2 的人都放进了res，在对res进行1到2报数
        return result(res, 2)
```

